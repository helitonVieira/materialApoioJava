aulas spring boot thymelyve https://www.youtube.com/user/alexegidio/search?query=Spring+Boot+%2B+Thymeleaf+%2B+JPA
site oficial do spring boot  ///      spring.io
vieirasystem2019@gmail.com   Asdf,.........
#######################################################################################################
PORTA 8080  OUTRO SERVIÇO JA UTILIZANDO A PORTA
######################################################################################################
1) netstat -noa | findstr 8080 
2) taskkill /PID "PID number" /F


https://downforeveryoneorjustme.com/ (verificar se o site esta no ar)

https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Headers  (saber mais headers HTTP)

###################################################################
ECLIPSE
###################################################################
  ctrl + F11 e preste atenção à View do Console. = executar  
  Alt + Shft + A = selecionar em bloco icone na barra ferramentas Toggle Block selection mode 
  shift + alt + M = seleciona as linhas ele exporta criando um metodo para estas linhas e se tiver em outro local ele ja instacia o metodo 
  Ctrl + shift + O = Organizar os imports 
  Seleciona as linhas Ctrl + /  = comentar varias linhas
  
    
   Sysout Ctrl+ ESP  criar o   System.out.println();
	
	
  variavel.getInstance() = buscar data atual

PESQUISA
  Ctrl + H busca geral 
  Ctrl+1 = traz sugestões para o que deve fazer 
  Ctrl + alt + H = buscar herarquia do metodo
  Ctrl + shift + T = abrir uma classe
  Ctrl + .(caractere ponto) =  ir para erro mais proximo
  F3 seleciona a variavel F3 vai para sua declaração
  Ctrl + 3 = procurar algo do menu 

MOVIMENTAR ENTRE TEXTO E ARQUIVOS
  Ctrl + pgUp e Ctrl + pgDown ou ctrl + F6  para alternar entre as abas abertas eclipse 
  F3  = direcionar para a classe ou metodo da linha do cursor 
MANIPULAR TEXTO
  Ctrl + Espaço = Completar
  ctrl + Alt + seta para baixo = copiar linha para baixo 
  Alt + seta = mover linha para cima ou para baixo 
  ctrl + shift + F = formatar o codigo
  Alt + shift + R = renomear variavel e classe e já altera todas referencias desta classe 
  
DEBUG  https://www.youtube.com/watch?v=zS7UG63we4g
	f6  = Proxima linha
	F5  = entrar dentro metodo
	F8  = proceguir
	
	PEGAR VALORES
		              Seleciona a variavel botao direito "Watch"  Mostra o valor da variavel na expressions
	CTR + SHIF + I	= Seleciona a variavel botao direito "Inspecionar"
	
	Variaveis pode alterar o valor 
	Metodo pode alterar em tempo de execução que ele volta para inicio 
	Criar Break Point de exceptions = Console msg em nullPoiter em azul click em cima pode criar break Point onde esta o erro 
	
	Botao direito na classe tem algumas opçoes de break
		ex: dentro de for selecionar hora que quer parar 
###################################################################
Intellij
###################################################################	

DEBUG
	F8 proxima linha
	F7 entrar dentro metodo
	F9 seguir 
	
###################################################################
CRIANDO TEMPLATE 
###################################################################

ctrl + espaço  (criando os seus metodos TEMPLATES)
WINDOWS PREFERENCE > DIGITE TEMPLATE > java > editor > NEW
 nome > 
 context > java (dentro de uma class)
           java Statements (dentro de um metodo de uma class)
		   java type members (dentro da class mais fora dos metodos)
descrition > uma qualquer 
Pattern > codigo a ser completado 

###################################################################
Explorando Views e perspectivas
###################################################################
Comentarios de marcação   Ctrl + 3  = tasks
	//TODO (algo que precisa ser feito)
	//FIXME (bUG conhecido que precisa ser corrigido)
	//XXX (Algo que precisa refatorar)
	

###################################################################	
DEBUG	
###################################################################
F6 (proxima linha )
F5 (Entrar no metodo)
F8 (continuar)
Ctrl + shift + D (mostrar valor variavel)
CTRL + shift + I (mostrar valor variavel)4




***************************

alt + shift + L (todos os atalhos do eclipse)						

##################################################################
paradigmas de programação - maneiras de resolver o problema 
##################################################################
	Imperativa	, procedural, estruturado , orientado a objeto

1)Imperativa - comando passo a passo de tudo que tem que ser feito 
	codigo grande com muita repetiçao 
	
2) Procedural - Funçoes diminuindo a repeticao do codigo 

3) estruturada - condicional,loop, try catch diminuição de codigo mais estruturado
				sistema pequeno 

4) Orientado a objeto - trazer mundo real para programação (classes,heranças,polimorfismo, encapsulamento)
						sistema grande


Paradigma Declarativo - programação funcional, logica, liguagem de marcaçao 
						procupa em fazer nao como foi feito sql 
						
						

#############################################
Principios SOLID
#############################################
	
	Spr(Sigle responsibility principle) - reponsabilidade unica - a classe tem que ter apenas uma tarefa 
		ex: class pedido separar parte que trata do item,outra class cuidando dos pedidos , outra cuidando da impressao
		*reaproveitamento de codigo mais facilmente
		*refatorar mais facil 
		*testes unitarios mais simples 
		*entendimento de codigo mais simples
	
	Ocp open close - aberto para extenção fechado para alteração 
					 tem a mesma regra do Design Patter Strategy 
					 sempre que uma classe precisa de varios if e tem
					 possibilidade de extender pode aplicar esta regra
					 
	    ex:folha de pagamento 
		errado:
			class ContratoClt {
				 public void salario(){
				 /*...*/
				 }
			}
			class ContratoEstagio {
				 public void bolsaAuxilio(){
				 /*...*/
				 }
		    class folha de pagamento {
				privado double saldo;
				
				public void calcular(String contrato){
				 if (contrato = "clt"){
					/*...*/
				 }else if(contrato = "estagio"){
					/*...*/
				 }				 
			}
		
certo: se resolve acrescentar mais um tipo PJ pode dar problemas e dificil manutenção	
	        
			interface Remuneravel{
				public function remuneracao();
			}
			
			
			class ContratoClt implements Remuneravel{
				 public void remuneracao(){
				 /*...*/
				 }
			}
			
			class ContratoEstagio implements Remuneravel{
				 public void remuneracao(){
				 /*...*/
				 }
				 
			class ContratoPj implements Remuneravel{
				 public void remuneracao(){
				 /*...*/
				 }
			}
			
		    class folha de pagamento{
				privado double saldo;
				
				public void calcular(Remuneravel contrato){
					this.saldo = contrato.remuneracao();
				}	
			}
	
	Lsp - classe derivada substituida pela class base
	Isp - principio da segregaçao - nao implementar interfaces que nao vai utilizar 
		ex: 
			public interface Ave {
				public void setLocalizacao(int longitude,int altitude);
				public void setAltitude(int altitude);/*existem aves que nao voa melhor criar outra interface com aves que voam assim nao havera metodos desnecessarios*/
			}
		
		    class papagaio implements Ave{
				public void setLocalizacao(int longitude,int altitude){
					/**/
				}
				public void setAltitude(int altitude){
					/**/
				}
			}
			class pinguim implements Ave{
				public void setLocalizacao(int longitude,int altitude){
					/**/
				}
				public void setAltitude(int altitude){
					/*pinguim nao voa melhor criar outra interface com aves que voam assim nao havera metodos desnecessarios*/
				}
			}
			
	D - depender das abstrações e nao de implementações
	


			
#############################################
Protocolo HTTP
#############################################


                   ___________                 REQUEST                ___________  
		  |           |   ------------------------------>    |           | 
		  | NAVEGADOR |                                      |  SERVIDOR |
		  |___________|                 RESPONSE             |___________|
                                  <------------------------------ 
						   
		REQUEST = seu navegador manda uma informação para o servcodEmpresaor 
		RESPONSE = resposta do servcodEmpresaor para o navegador
         ex:  informação enviada via TCP - IP que define o trajeto (roteadores que vai percorer)	
			(IP) traça a rota 
			(TCP) organiza os pacotes de forma que nao perca e se nao chegar todos ele manda novamente 
			e organiza em ordem servcodEmpresaor tem as portas ex http 80 com isso ele sabe para onde
			mandar ai o servcodEmpresaor sabe onde buscar (servcodEmpresaor: apache tomcat node)
		 
Camada de rede sao 7 mais vamos ver 4 mais importantes
	
         --------------  
		 1 - APLICAÇÃO   > http,ftp,dhct,smtp  é a camada do software programa
		 --------------
		 2 - TRANSPORTE  > TCP,UDP
		 --------------
		 3 - REDE        > IP
		 --------------
		 4 - HARDWARE    > CABOS 	
		 --------------
		 
		 sai do navegador passa pelo 1>2>3>4 chega no servcodEmpresaor pelo 4>3>2>1
						   
Linhas de pedcodEmpresao 		
		GET       pegar
        POST      alterar
		PUT       editar todo corpo  
		PATCH     editar apenas um valor 
		OPTIONS   verificar se aceita a operaçao
		HEAD      manda pedcodEmpresao para retornar apenas os cabeçarios
		TRACE     retorna como a msg chegou
		CONNECT	  
	  
	  
Erros http 

        1XX: Informativo – a solicitação foi aceita ou o processo continua em andamento;
		2XX: Confirmação – a ação foi concluída ou entendida;
		3XX: Redirecionamento – indica que algo mais precisa ser feito ou precisou ser feito para completar a solicitação;
		4XX: Erro do cliente- indica que a solicitação não pode ser concluída ou contém a sintaxe incorreta;
		5XX: Erro no servidor – o servidor falhou ao concluir a solicitação.	  
	  

Lista de Código de Status HTTP
Agora que você sabe o que é HTTP e HTTPS, confira essa lista com códigos HTTP, que tem os códigos mais comuns e outros que raramente são usados, baseado no W3.org.

Código do Status HTTP
(Status-code)	Significado do código HTTP
(Reason-Phrase)	Significado do código HTTP
         100	Continue							Continuar
         101	Switching Protocols				Mudando Protocolos
         102	Processing						Processando
       
		 200	Ok								Ok
         201	Created							Criado
         202	Accepted						Aceito
         203	Non-Authoritative Information	Não autorizado
         204	No Content						Nenhum Conteúdo
         205	Reset Content					Resetar Conteúdo
         206	Partial Content					Conteúdo Parcial
         
		 300	Multiple Choices				Múltipla Escolha
         301	Moved Permanently				Movido Permanentemente
         302	Found							Encontrado
         303	See Other						Veja outro
         304	Not Modified					Não modificado
         305	Use Proxy						Use Proxy
         306	Proxy Switch					Proxy Trocado
         
		 400	Bad Request						Solicitação Inválida
         401	Unauthorized					Não autorizado
         402	Payment Required				Pagamento necessário
         403	Forbidden						Proibido
         404	Not Found						Não encontrado
         405	Method Not Allowed				Método não permitido
         406	Not Acceptable					Não aceito
         407	Proxy Authentication Required	Autenticação de Proxy Necessária
         408	Request Time-out				Tempo de solicitação esgotado
         409	Conflict						Conflito
         410	Gone							Perdido
         411	Length Required					Duração necessária
         412	Precondition Failed				Falha de pré-condição
         413	Request Entity Too Large		Solicitação da entidade muito extensa
         414	Request-URL Too Large			Solicitação de URL muito Longa
         415	Unsupported Media Type			Tipo de mídia não suportado
         416	Request Range Not Satisfiable	Solicitação de faixa não satisfatória
         417	Expectation Failed				Falha na expectativa
		 
	        500	Internal Server Error			Erro do Servidor Interno
         501	Not Implemented					Não implementado
         502	Bad Gateway						Porta de entrada ruim
         503	Service Unavailable				Serviço Indisponível
         504	Gateway Time-out				Tempo limite da Porta de Entrada
         505	HTTP Version Not Supported		Versão HTTP não suportada
         
#############################################
Configuraçao IDE 
	window > preferences > 
	window > preferences > pesquisa jre (configurar )


#############################################
Estruturas e pastas no java 
#############################################
1) model - domain  (classes)
2) dto          (model resumido somente com os campos que vai usar)
3) domain.enum  (enumeradores obj com valores definidos ex: tipo(fisico,juridico) , estadoPagamento(pendente, andamento, liquidado))
4) repository   (usado para comunicar com o banco de dados não diretamente mais crias as Query vai ser usadas no serviços)
5) resources ou controlers (endpoint para receber a comunicação com as outras api)
6) service      (responsavel comunicação com banco dados, domain, repository, controlers tbm responsavel pela regra de negocio )
7) utils        ()
8) validation   ()
9) service.exception  controler.exception  ()
10)security     () 
11)config       ()



#############################################
Maven - Instalando manual Spring tool e o intellyj já vem com maven imbutido(usa quando vc quer utilizar os comandos manual cmd e git bash)
#############################################
Oque é o maven 
	E uma estrutura de projeto que facilita a compilação em qualquer IDE	
	Maven (organiza seu projeto para compilar em quanquer framework)

    PASTAS PADRAOo
	src/main/java  (todos os arquivos .java)
	src/main/resouces (todos arquivos que nao é java exemplo .properties)
	src/test/java (tudo que for arquivos de teste)
	target (tudo que vc compilar)
	
	pom.xml 
		version SNAPSHOT (esta em desenvolvimento) RELESE(esta em producao)
		
		Parent (Se o projeto basea em alguem baixa varias bibliotecas.
		Obrigatorio no spring org.springframework.boot, ele faz um monte de configuracao para o spring)
		
		Dependencias (btnDireito > Spring > add Starts)
			spring-boot-start-web (informa que é um projeto web)
			spring-boot-devtools (auto reloud quando tem alteração start automatico) (btnDireito > Spring > add Devtools)
			spring-boot-jpa (persistencia banco)	
	


	<dependency> Quando nao é informada a <VERSION> 0.0.0 </VERSION> o Spring Boot busca a versão recomendada pela versao do Spring responsavel
				por isso é o <parent> </parent> para verificar basta entra no maven > spring-boot-starter-parent > pesquisar a biblioteca
	
	<parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.5.6</version>
        <relativePath/>
    </parent>		
			
	<dependency>
		<groupId>org.springframework.kafka</groupId>
		<artifactId>spring-kafka</artifactId>
	</dependency>
	
	
Baixar o Maven https://maven.apache.org/download.cgi > Arquivos > arquivos zip binario
Descompaquitar o arquivo

No Windows variaveis de Ambiente
    Criar uma nova variavel de usuario 
       nome =   M2_HOME    
       valor(caminho onde descompactou o maven) =  C:\apache-maven-3.8.4
    No Path da variavel de usuario adicione
	C:\apache-maven-3.8.4\bin  
	
     salva e fecha as variaveis de ambiente 
     
Testar 
	Abre o cmd digita:  mvn -version
	
Caso não funcione 
	Variaveis de Ambiente > variaveis de sistemas > path add C:\apache-maven-3.8.4\bin 
-----------------------------------------------------------------------------------------------------------------------
CONFIGURAR O MAVEN NO ECLIPSE IDE 	
	
http://luizricardo.org/2014/06/instalando-configurando-e-usando-o-maven-para-gerenciar-suas-dependencias-e-seus-projetos-java/	

mvn eclipse:clean

mvn eclipse:eclipse  (if irá preparar o arquivo eclipse .classpathpara você)


#############################################
SPRING BOOT =  https://blog.betrybe.com/framework-de-programacao/spring-boot-tudo-sobre/
#############################################
  Oque é:
  Spring Boot = Spring Framework + Servidor embutido + Configuraçoes iniciais prontas

	veio para facilitar as configurações iniciais de um projeto
	servidor embutido 
	annotations = otimiza codigo
  
	O Spring Boot serve para gerenciar dependências de forma opinativa e automática
   
   VANTAGENS 
	Redução drástica no tempo de desenvolvimento
	Servidor embutido
	Pom.xml organizado
   
   SPRING INITIALIZER facilita a criação dos nossos projetos 
  
  -----------------------  
   3 PRINCIPAIS COMPONENTES DO SPRING BOOT?
   *SPRING BOOT STARTER 
	possui inicializadores que unificam diversas dependências e configurações dentro de uma única dependência.
	
   *SPRING BOOT AUTOCONFIGURATOR
	@SpringBootApplication dentro tem varias anotações que configura o spring
	responsável por dar as coordenadas de configuração para a aplicação
	une as configuraçoes padroes com as que o desenvolvedor implementou
	
   *SPRING BOOT ACTUATOR
	monitorar a saúde da nossa aplicação
	fornecendo métricas
   ---------------------------------	
   

   MÉTODOS MANIPULADORES DE REQUISIÇÕES	
   
   @RestController  faz com que o Spring Boot consiga entender que essa classe é um controlador. 
   @RequestMapping é utilizada para implementar URL. Essa notação suporta os métodos GET, POST, PUT, DELETE e Patch.
   @Configuration  Informado em cima da classe quer dizer que quando for iniciar o projeto vai passar por esta classe normalmente carregando parametros
   ---------------------------------
   
   SPRING BOOT VS SPRING MVC 
     Spring Boot e o Spring MVC são frameworks diferentes
     projeto web utilizando o Spring Framework, você precisaria configurar o Spring MVC para que o seu projeto se tornasse web
     Já com o Spring Boot é só  adicionar o módulo Web que você teria as configurações iniciais do Spring MVC.
     
	SPRING BOOT 
	   não faz com que o nosso projeto seja web.
	
	SPRING MVC (Model, View, Controller) 
	   é uma estrutura orientada a HTTP, ou seja, ele “escuta” as requisições feitas na aplicação web
   ---------------------------------
   
   
  DEVTOOLS SPRING BOOT
	reiniciemos o projeto automaticamente quando alterado.
	sejam habilitadas algumas configurações por padrão que são necessárias para o desenvolvimento, 
	  impedindo que tenhamos que realizar essas configurações na application.properties.
	seja desabilitado o cache das páginas em HTML quando estamos no ambiente de desenvolvimento.
  
  ---------------------------------
  3. SAIBA QUANDO USAR CADA INJEÇÃO DE DEPENDÊNCIA SPRING
  
  Muitas vezes precisamos criar classes que vão “compor” a funcionalidade de outra classe. Isso faz com que a classe X precise saber como instanciar e como utilizar a classe Y, o que faz com que elas se tornem dependentes.

Com isso, o Spring “herdou” os conceitos de Inversão de Controle e Injeção de Dependências que vieram do SOLID. A Inversão de Controle possibilita que outra classe saiba quando é necessário criar e executar alguma função.

Já a Injeção de Dependência se preocupa em manter o fraco acoplamento entre as classes e tira a responsabilidade de uma classe saber como instanciar a outra.

Portanto, avalie bem o seu projeto, leia a documentação do Spring e entenda qual a melhor maneira de utilizar cada injeção de dependência.
  
  ---------------------------------
  
  ---------------------------------
  
  ---------------------------------
  MICROSSERVIÇOS,  sistema que tem apenas uma responsabilidade.
 
 
-----------------------------------------------------------------------------------------------------------------------
CRIANDO PROJETO MAVEN PELO SPRING

	File > New > project > Maven > Maven Project 
		X - Create a simple project ...  (marcar) se nao marcar vc vai para opçao de escolher um modelo de projeto
		Next@
		Group id:  com.vsystem.financeiro  (indentifica o projeto como unico)
		Artifact id:  contas-pagar-api (nome do projeto)
		Version: 0.0.1-SNAPSHOT  (versão do projeto "SNAPSHOT" significa que ainda esta em desenvolvimento)
		Packaging: jar (.jar armazena classes de uma biblioteca que podemos usar na nossa aplicação., server tomcat ja vem imbutido)
		           war (.war geralmente é responsavel por compactar todos os arquivos necessarios para rodarmos uma aplicação WEB (HTML, CSS, JS, Imagens, Classes Java, JAR's, etc)usar o server externo) https://www.youtube.com/watch?v=UQuinl-kHxo
		Finaliza
		
	pom.xml
	     (Definições que é um projeto maven)
	     
		<groupId>com.hsvSystem.mavenTreinamento</groupId>
		<artifactId>treinamento-maven</artifactId>
		<version>0.0.1-SNAPSHOT</version>

--------------
PROPERTIES  (DEFINIR QUAL VERSAO DO JAVA VAI ESTAR UTILIZANDO)

  <properties>
  	<maven.compiler.source> 1.8 </maven.compiler.source>
        <maven.compiler.target> 1.8 </maven.compiler.target>
		<springdoc-openapi-ui-version>1.6.6</springdoc-openapi-ui-version>
  </properties>	
-------------------------  
 CONFIGURAR ECLIPSE PARA JAVA 8 1.8 
	1) windows > preference > java > installed JREs   (add > standard VM > selecione a pasta raiz JDK a ser usada) DOS comando P/ saber =  SET JAVA_HOME
		selecione a nova versao >click apply
	2)windows > preference > java > installed JREs > Execution Environments (JavaSE-1.8) click > selecione > apply and close	
______________________________________________ 
 ERRO NO <project ...PSTS
  (passa o http para https)
______________________________________________
  
  DECLARAÇÃO DE VARIAVEIS PELA PROPERTIES PODE SER USADA NAS DEPENDENCIAS 
  
        <dependency>
    		<groupId>org.springdoc</groupId>
    		<artifactId>springdoc-openapi-ui</artifactId>
    		<version>${springdoc-openapi-ui-version}</version>
		</dependency>

--------------
DEPENDENCIES () 
    1° Tenta baixar do repositorio local na maquina se nao tiver baixa da web (Maven Dependencies esta caminho do repositorio local) cd  ~/.m2/repository/org/apache  (~/ pegar o usuario logado)

    2º BtnDireito > Maven > Update projet > X marcar Force Update of Snapshots/Releases > ok

  <dependencies>
  	<dependency>
  		<groupId>org.apache.commons</groupId>
  		<artifactId>commons.lang3</artifactId>
  		<version>3.12.0</version> 
  		<scope>compile</scope> <!-- compile(disponivel em todo class path do projeto ), test (disponivel somente pasta test),runtime(disponivel na execução e nao na compilação) -->
  	</dependency>
  </dependencies>
  
  Dependencias transitiva (quando baixa uma dependencia e ela tras outras dependencias)	
  Comando VISUALIZAR DEPENDENCIAS PROJETO mvn dependency:tree
-----------------------------------------------------------------------------------------------------------------------	
COMANDOS DO MAVEN
	mvn -version  (versao saber se esta funcionando, local onde esta instalado)
	
   CRIAR PROJETO  mvn -B archetype:generate -Dgroup=br.vsystem -DartifactId=maven  (CRIA PASTA maven QUE ESTARA O PROJETO src e pom.xml)
	
	VISUALIZAR DEPENDENCIAS PROJETO mvn dependency:tree
	
	LISTAR ls : verifica se esta no diretorio que tem o pom.xml
	
	
	
	COMPILAR E EMPACOTAR PROJETO 
		ls : verifica se esta no diretorio que tem o pom.xml
		mvn package (compilar)
		mvn clean package (limpa compilar)
		mvn -DskipTests clean install (gerar war ou jar sem rodar o teste)
		
        DELETAR PASTA TARGET:  mvn clean
   	
#############################################
Apacha Ant  http://ant.apache.org
#############################################	
	O QUE E O ANT
	
	E uma API voltada par a automatização de tarefas
	Ex TAREFAS: 
	    Copia de arquivos, 
		Compilação de codigo- fonte, 
		Compactação de arquivos, 
		Geração de arquivo JAR
		
	UTILIZANDO O ANT 

	1 - LINHA DE COMANDO 
		***Processo feito para executar linha de comando***
		
		a - Baixar   http://ant.apache.org > Dowloading Binary distribu .zip 
		b - Criar as variaveis de ambiente
	
		(usuario) ANT_HOME = D:\program\apache_ant
		(Path) D:\program\apache_ant\bin
	
	TESTAR PELO CMD  
		set ant_home  (verificar se esta configurado )
		set path  (verificar se esta configurado )
	
	
	2 - INTEGRA A IDE ECLIPSE
		Build File 
			As tarefas do Ant deve executar fica aqui dentro
			tem padrao definido xml 
			chamado build.xml mais pode ter outro nome se quiser
			
			
	ESTRUTURA DO BUILD FILE	
	  formato xml
	  
	  Cada build file tem 1 project 
		1 ou mais target (ALVO)
			1 ou mais task (Tarefas)

Atributos 
	name = define o nome para o build file
	defaul = a target que vai iniciar 
	depends = indica que para executar tem que executar o depends primeiro 

TASKS (documentação tem lista de task ja definidas) minuto 9:50 https://www.youtube.com/watch?v=JfT-KJBNMBc 
http://ant.apache.org > manual > Ant tasks > List of Tasks

	javac = compilar tudo que esta neste caminho 
	destdir = diretorio onde quer gravar os arquivos .class
    <echo>passar msg é o msm que system.out.print </echo>
	
	
PROPERTY (DECLARAÇÃO DE VARIAVEL COM CHAVE VALOR )
	* declarado project vizivel para todo projeto global
	* declarado dentro do target local somente para ele
  DECLARAÇÃO	
	<property name="module_dir_DP" value="RoboDP_Java"/>
  RECUPERAR O VALOR
    "${module_dir_DP}"
	
	
-----
ex 1			
<project basedir="." default="all" name="DP">
      
	<!-- Custom Properties -->
	<property name="module_dir_DP" value="RoboDP_Java"/>
	
    <target name="compile" description="compila o codigo">
		<javac srcdir="src" destdir="build">	
	</target">
	
	<!-- Build All Modules -->
	<target name="all">
		<!-- DP EAR Task -->
		<echo></echo>
		<echo></echo>
		<echo>Building RoboDP EAR</echo>
		<ant dir="${module_dir_DP}" />		
	</target>
	
	
</project>

----
ex: 2 Automatização do processo backup copiar o projeto depois zip
			
<project basedir="." default="zipFile" name="backup">      
			
    <target name="copyFiles"  description="copiar o arquivo">
		<!-- Criar o diretorio para backup caso nao exista -->
		<mkdir dir="backup" />
		
		<!-- copy Copiar o arquivo informa onde vc quer que seja copiado -->	
		<!-- fileset os arquivos que vc quer copiar -->
		<copy todir="backup">
			<fileset dir="src" />
		</copy>
	</target">
	
	
	<target name="zipFile" depends="copyFiles">
		<!-- destfile = arquivo de destino a ser criado, basedir="arquivo a ser copiado"  -->
		<zip destfile="backup/src.zip" basedir="backup">	
	</target>
	
	
</project
-----
ex: 2.1  Uso Property Automatização do processo backup copiar o projeto depois zip
			
<project basedir="." default="zipFile" name="backup">      
	
	<property name="srcDir" value="src"/>
	<property name="backupDir" value="backup"/>
	
    <target name="copyFiles"  description="copiar o arquivo">
		<!-- Criar o diretorio para backup caso nao exista -->
		<mkdir dir="${backupDir}" />
		
		<!-- copy Copiar o arquivo informa onde vc quer que seja copiado -->	
		<!-- fileset os arquivos que vc quer copiar -->
		<copy todir="backup">
			<fileset dir="${srcDir}" />
		</copy>
	</target">
	
	
	<target name="zipFile" depends="copyFiles">
		<!-- destfile = arquivo de destino a ser criado, basedir="arquivo a ser copiado"  -->
		<zip destfile="${backupDir}/src.zip" basedir="${backupDir}">	
	</target>
	
	
</project>

----

COMO CRIAR UM ARQUIVO ANT NO ECLIPSE 
	https://www.youtube.com/watch?v=nlW3x6crAS8
	
EXECUTAR O TARGET POR LINHA DE COMANDO 
		CMD  ant (roda o ant default)
			
			
	
		
	
#############################################
Spring Boot
#############################################
Criando projeto sempre pela pagine do spring
https://start.spring.io/
1) vai escolher se o projeto é maven ou gradle 
2) Group = br.com.hsvieira   ( convenção no java com nome da empresa que trabalha )
3) artifact = exemplo-gradle ( nome do projeto que vc vai trabalha )
4) informa as dependencias: web é principal

projeto criado extrai a pasta 

No Intellij 
	*Projeto Maven importa pelo pom.xml
	 Do lado direito tem os plugns do maiven 
		install > Quando termina de build Cria a pasta target onde o projeto vai estar em tempo de execução
	        Plugin > spring boot > run (neste momento sobe a aplicação)
		http://localhost:8080
		
		executando pelo MSdos =  java -jar target/nomeArquivo.jar   
			fica  java -jar target/exemplo-maven-0.0.1-SNAPSHOT.jar  (fica dentro pasta target o arquivo jar)

		*Projeto Gradle importa pelo build.gradle (que é arquivo de config principal)
		Do lado direito tem o gradle
		build > build   =  faz a função do install, Quando termina de build Cria a pasta build/libs onde o projeto vai estar em tempo de execução
		Task > aplication > bootRun (executar subir a aplicação pelo intellij)
		
		executando pelo MSdos =  java -jar target/nomeArquivo.jar   
			fica  java -jar build/libs/exemplo-maven-0.0.1-SNAPSHOT.jar  (fica dentro pasta target o arquivo jar)
			
#############################################
application,properties  (mais informaçoes na linha 2050)
#############################################	
  spring.jpa.database=POSTGRESQL      
  spring.datasource.platform=postgres
  spring.jpa.show-sql=false  // mostrar as consultas sql no console false(produção)   true(desenvolvimento)
          
  spring.jpa.hibernate.ddl-auto=none   //forma que vai modificar o banco (none produção) create ou update(desenvolvimento)
  spring.datasource.driver-class-name=org.postgresql.Driver
  spring.datasource.url=jdbc:postgresql://localhost:5432/osworks?createDatabaseIfNotExist=true&useSSL=false
  spring.datasource.username=postgres
  spring.datasource.password=851213

#############################################
Java Basico - https://www.youtube.com/watch?v=IshatInRiLo&list=PLtchvIBq_CRTAwq_xmHdITro_5vbyOvVw
               Aula de Java 001 ate 099
#############################################
 comentario 
	// para uma linha  
	/* para varias linhas */   
	<!--para html -->

Imprimir no console 
	System.out.print("")

Criação de variavel 
	String nome = "nome";
	int idade = 32;
	double altura = 1,25;
	char sexo = "M";
	boolean casado = true;
	
Operadores 
		aritimeticos(+-*/)  ex: soma = 8+3;
		mod %  ex: resto = x%y;
		
Comparação  (<,>,>=)  
		== iqual  ex:  10==10;
        != diferente	ex:  10!=10;
		
		https://pt.stackoverflow.com/questions/3905/como-comparar-strings-em-java#:~:text=O%20m%C3%A9todo%20compareTo%20retorna%3A,for%20menor%20que%20a%20segunda
		COMPARAÇÃO DE String
		
		String usa  != para null          if (nome != null) {}
		
		System.out.println("STR".equalsIgnoreCase("str")); //retorna true
		System.out.println("###STR###".contains("STR")); //retorna true
		System.out.println("str1".compareToIgnoreCase("STR2")); //retorna -1, ignorando a capitalização
		System.out.println("str1".startsWith("str")); //returna true, pois "str1" começa com "str"
		System.out.println("str1".endsWith("r1")); //return true, pois "str1" termina com "r1"
		System.out.println("str2".matches("\\w{3}\\d")); //return true, pois corresponde à expressão regular
		

Vazio 
		String str1 = "";
		System.out.println(str1.isEmpty());
		System.out.println(str1.length() == 0);
		System.out.println(str1.equals(""));
		
		
		
Incremento  (++ e --)
			++valor; implementa o valor na mesma linha
			valor++; implementa o valor so na proxima linha

 Condições 
      IF:
		if(expressao){
			aplica
		}else{
		aplica};
		
		IF DIRETO    (condição>0) ? “verdadeiro” : “Falso”
		ex:
		int numeroDias = //valor entre 1 e 30
         System.out.println((numeroDias <= 15) ? “Primeira quinzena” : “Segunda quinzena”);
		
 Aula 14) expressao and(&&)  if ( x>1 && x<20)
			 or(||)  if ( x>1 || x<20)
			 not(!)  if (!true) 
		
SwitchCase
			int diaSemana;
			
			String nomDoDia ;
			
			switch(diaSemana){
			case 1:nomDoDia="Domingo";break;
			case 2:nomDoDia="Segunda";break;
			case 3:nomDoDia="Terca";break;
			default:nomDoDia="Dia invalido";break;
			}

While:
	int x = 1;
	while(x<10){
		System.out.print(x);
		
		if(x ==8){
			break;		
		}
		x++;
		
	}
	
DoWhile:
		int x = 1;
		do{
			System.out.print(x + "passara pelo menos uma vez");
			x++;
		}while (x<10);
		
For:
	for(int i=1;i<10;i++){
		System.out.print(x);
	}
	
Vetor
		String[] nomes = new String[3];
		nomes[0] = "gugu0";
		nomes[1] = "gugu1";
		nomes[2] = "gugu2";
    tambem pode ser escrito desta maneira
	
		String[] nomes ={"gugu0","gugu1","gugu2"};
		System.out.print(nomes[1]);
		
Foreach:
	    for (String nome : nomes){
			System.out.print(nome);
		}
		
		nomes.forEach(nome -> {
		    //pode colocar as condições if 
			System.out.print(nome);
		})
		
Matriz 
		int numeroDelinha = 2;
		int numeroDeColuna = 2;
		String[][] nomes = new String[numeroDelinha][numeroDeColuna];
		nomes[0][0] = "gugu0";
		nomes[0][1] = "gugu1";
        nomes[1][0] = "ana";
		nomes[1][1] = "kelven";		
	tambem pode ser escrito desta maneira		
		String[] nomes ={{"gugu0","gugu1"},{"ana","kelven"}};
		System.out.print(nomes[1][0]);	

Classe
		public class Pessoa{
			int id; //atributo
			String nome; //atributo
		}	

Instanciando a class 
		Pessoa pessoa = New Pessoa();   // objeto pessoa , New instancia da class
		
metodo (tipoDeRetorno nomeMetodo)
       
	   //void vazio sem retorno
	   void durmir(){   
			System.out.print("Zzzzzzzzzzzzz");
        }	
        
		//retorna algo
		String apresentar(){   
			Return System.out.print("Meu nome é Heliton");
        }	
		
		//passagem de parametro
		String apresentar(String nome){   
			Return System.out.print("Meu nome é: " + nome);
        }
		
    //passar varios parametros indefinido
		int somarNumeros(int ... numeros){
			for(int n : numeros){
			  soma +=n;
			}
			return soma;
		{
		
		int soma = classe.somarNumeros(10,25,32,65);
		
Construtores - serve para inicializar os valores dos atributos 
	Também conhecidos pelo inglês constructors, os construtores são os responsáveis por criar o objeto em memória, ou seja, instanciar a classe que foi   definida. Eles são obrigatórios, msm que não colocar as classes ja vem com construtor vazio embutido

			public class Pessoa{
				String nome;
				
				//Construtor vazio ja vem de padrao mais é bom criar novamento pois 
				//se for criado um com argumento ele sera apagado 
				//construtor vazio
				Pessoa(){
					nome = "Carlos"; //adicionando valor ao atributo nome
				}
				//construtor com argumento
				Pessoa(String nome){					
				}				
			}
			
This:	referencia a class 
     
        public class Pessoa
					String nome = "carlor";
					Pessoa(){
						String nome = "bruno";
						System.out.print(this.nome); //carlos
						System.out.print(nome); //bruno					
					}
		 public class Pessoa
					String nome;
					Pessoa(Sting nome){	
							this.nome = nome; //nome da clase recebe o nome passado pelo metodo  
					{
	
Atributo static - ele é unico não muda 
Metodo static - só acessa os atributos staticos

Pacote ou package - para acessar de pacotes diferentes tem que importar ctrl + Shift + o 
	import nomePacote.NomeClasse;
	 
package atributo e metodos em outro pacote só e acessado se o modificador de acesso for public
		public Sring nome;
		private String senha;
		
		public void dormir(){
			System.out.print("zzzzzzzzzzzzzzzz");
		}
	     
		 public boolean verificarSenha(String senha){
		  ...
		  return true ;
		 }


Encapsulamento  - proteger os atributos maior controle de entrada e saida Get e Set
         btn Direito > Souce > Generator Get and Set
		 
         public String getNome(){
			return nome;
		 }
		 
		 public void setNome(String nome){
			this.nome = nome ; 
		 }


####################################################################################################################################################		 
BIBLIOTECA PROJECT LOMBOK 	(Automatiza os get set hashcode equals)  https://www.youtube.com/watch?v=W0ywxkvc4_M
		 
		 deve ser instalado pelo maven arquivo pom.xml biblioteca lombok 
		 
		 criado automaticamente com as seguintes anotaçoes 
		 - em cima da class para todas propriedades
		 - em cima do atributo somente para o unico atributo 
	
	ctrol + O (ver as propriedades da classe)
    -------------
    ERRO IMPORTANTE	LOMBOK NAO FUNCIONA VER MIN 6:40 (https://www.youtube.com/watch?v=W0ywxkvc4_M)
	  1 fecha o eclipse
	  2 entra na pasta do maven que foi instalado o lombok
		ex: C:\Users\hvieira\.m2\repository\org\projectlombok\lombok\1.18.24
	  3 execute o comando =   java -jar lombok-1.18.24.jar
		vai abrir a tela do lombok 
		localizar seu eclipse caso não ache click specify location 
	  4 click em install/update	
	  5 pode fechar Quit.. 
		abri o eclipse que o lombok vai funcionar 	
	
	
	------------------------------
	Poderoso comando que ja vem com todas as anotações 
		 @Data - cria @Getter @Setter  @equalsAndHashCode  @RequiredArgsConstructor(@NonNull em cima propriedades para passar para construtor argumento)
	------------------------------
		 @Getter 
		 @Setter 
		 
		 @Getter(AccessLevel.PACKAGE) - elevar a nivel do pacote  
		 @Getter(AccessLevel.Privente) - propriedade fica privada não acessivel 
		 @Getter(AccessLevel.NONE) - deixa oculto nem aparece 
		 
	------------------------------
	ToString
	Para que serve o ToString ????
		1 - Sempre que cria a classe ex: Cliente ja vem com o toString que pertence a classe Object
			mas se não for subscrito ele tras um codigo ao inves das informaçoes por isso tem que criar o msm
	
	------------------------------
		 @ToString - implementar o metodo ToString com todas propriedades em cima da classe
		 @ToString.Exclude - Em cima da propriedade não vai para o metodo @ToString
	outra forma de trabalhar com  @ToString
		 @ToString(onlyExplicitlyIncluded) - implementar o metodo ToString com as propriedades que for determinadas @ToString.Inclide
		 @ToString.Inclide - Em cima da propriedade vai para o metodo @ToString
	------------------------------	
                @equalsAndHashCode  - compara com todas propriedades
		@equalsAndHashCode (onlyExplicitlyIncluded) - vc determina qual propriedade quer comparar @equalsAndHashCode.Include	
		@equalsAndHashCode.Include - em cima da propriedade que quer atribuir ao @equalsAndHashCode
	------------------------------
                @AllArgsConstructor - gera construtores com todos argumentos todas propriedades
		@NoArgsConstructor - gera construtor vazio sem argumentos 
		@RequiredArgsConstructor - vc determina com @NonNull na propriedade qual vai estar no construtor
        ------------------------------
		@Builder - informado em cima da classe Facilita o jeito de fazer o set a classe 
		
		         
			
			ex: jeito normal 
				Cliente cli = new Cliente();
				cli.setId(1L);
				cli.setNome("Heliton");
				
			ex: com Builder
				Cliente cli = Cliente.builder()
				.id(1L)
				.nome("Heliton")
				.build();
				
		@Singular - informado em cima propriedade List
                        ex:
			//declarando na classe 
				@Singular   - (pega a propriedade telefones e passa para o singular retirando o "S"
						existem palavras em ingles que compilador não consegue traduzir por isso é bom ja definir qual vai ser 
						palavra usada com  ex: @Singular("informarTelefone")  )
				private List<Telefone> telefones = new ArrayList<>();
			
			//carregando no set
				Cliente cli = Cliente.builder()
				.id(1L)
				.nome("Heliton")
				.telefone(new Telefone()) //caso coloque o nome ai teria ficado .informarTelefone(new Telefone())
				.telefone(new Telefone())
				.build();
	-------------------LOG LOGGER -----------	
				@Slf4j - em cima da class 
	LOG 
	biblioteca a ser usada: 
	
			import org.slf4j.Logger
			import lombok.extern.slf4j.Slf4j;	
			import org.slf4j.LoggerFactory;
	
	
	@Slf4j
	Public class Cliente
	private static final Logger log = LoggerFactory.getLogger(Cliente.class) - //  @Slf4j em cima da class elimina esta linha deixa mais elegante o codigo 
	
	//uso
	log.info("Teste");
	log.warn();
	log.error(); 
	
	//uso desses tem que ser configurado app.propert para aparecer 
	log.trace();
	log.debug();
	
	//configuração application.properties
		erarquia dos log
			log.trace();
			log.debug();
			log.info("Teste");
			log.warn();
			log.error();
		
		#logging
		logging.level.root=INFO // padrao que mostrara apartir do info o warn e trace nao aparece 
		logging.level.br.com.agenda = DEBUG // (br.com.agenda)caminho na aplicacao apartir deste caminho aceita os log debug para aparecer no console  
	    logging.level.br.com.conta = DEBUG // pode ir liberando por parte a aplicacao
		
		
	Existem outras para log que ja esta implementada no lombok como: @Log4j, @Log4j2 , @CommonsLog 
	
	https://www.google.com/search?q=como+pegar+as+informa%C3%A7%C3%B5es+do+body+no+java+utilizando+logger.info&sca_esv=ae2d012acb0463ba&rlz=1C1FCXM_pt-PTBR1012BR1012&sxsrf=ACQVn083NwkjSl_7BGvLB0WsGyAYLBfjwQ%3A1706796880104&ei=UKe7Za70Bdfb5OUPl7-g4Ao&udm=&ved=0ahUKEwiu3PftqYqEAxXXLbkGHZcfCKwQ4dUDCBE&uact=5&oq=como+pegar+as+informa%C3%A7%C3%B5es+do+body+no+java+utilizando+logger.info&gs_lp=Egxnd3Mtd2l6LXNlcnAiQmNvbW8gcGVnYXIgYXMgaW5mb3JtYcOnw7VlcyBkbyBib2R5IG5vIGphdmEgdXRpbGl6YW5kbyBsb2dnZXIuaW5mbzIFECEYoAEyBRAhGKABMgUQIRifBUjFggFQlAtYwXZwAngAkAEAmAHvAaABvRiqAQYwLjIwLjG4AQPIAQD4AQHCAgoQABhHGNYEGLADwgIIECEYoAEYwwTiAwQYACBBiAYBkAYI&sclient=gws-wiz-serp#fpstate=ive&vld=cid:e1a246f7,vid:ICfYdaqz9Hk,st:0
	------------------------------	
	
	////////////////////////////////////////////////////++
	
	<dependency>
<groupId>com.google.code.gson</groupId>
<artifactId>gson</artifactId>
<version>2.9.0</version>
</dependency>
</dependencies>

private static final Gson gson = new Gson();
LOGGER.info("<<<<<REQUEST>>>>> de fluxoFinanceiro/porValorParcela: {}", gson.toJson(calculoValorRequest));


		
##End####################################################################################################################################################		
Herança - extends  só pode ter 1 classe pai 

         public class Animal {
			 public double peso;
			 public void falar(){
				System.out.print("animal dormindo")
			 }
		}		
	--------------  // herda atributos e metodos da classe animal 
		public class Cachorro extends Animal{
			 
		}	

Sobrescrita metodos   // metodo existe na class pai e filha mesmo nome msm parametros mais hage de forma diferente
    
	public class Galinha extends Animal{
     public void falar(){ //nas 2 class pai e filha tem o metodo falar ele sempre utiliza a sobrescrita na filha
				System.out.print("cocorico")
			 }		
			 
			 
classes Abstract - que nao pode ser instanciadas ex (class Animal  class Gato class Cachorro )  Animal pode ser uma class abstract
			   public abstract class Animal
			   public abstract void fala.r(); //metodo abstract o primeiro metodo concreto que herdar deve sobrescrever este metodo falar()
			 
			 
Classe Final - quando e a ultima classe ou seja nao pode ser herdada ex: class(Animal , Cachorro, Gato) cachorro e gato pode ser uma class final			 
	public final class Cachorro extends Animal{
		final String habitate = "Planeta terra" // atributo nao muda		
	}
	
Interface - 100% abstract so pode ser herdada de outra interface
    Interface classe que tem expecificações para outras classes, classe que herda tem que implementar todos os metodos
	A Interface obrigar o programador a seguir o padrão do projeto, 
	obriga a implementar seus métodos, ele deverá sempre seguir o padrão de implementação da Interface.
	Quando devo implementar uma interface???? deve se pensar como um contrato se tudo for obrigatorio implemente a interface definindo como um padrao.	
	
	public interface Animal {
		String habitat = "Planeta terra" //automaticamente ja é public abstract final  e os atributos tem que ser inicializados
		void durmir(); // metodos são public abstract por padrao
		
		//*obs classe não pode extends herdar de uma interface elas implementao
		
		-----------
		
		public class Pombo implements Animal{
			public void durmir(){ //interface nao precisa do public ja na implementação precisa
			}
		}
		
		-----------
		//classe pode ter mais de 1 implemento
		public class Pombo implements Animal,Ave{ //implements Animal,Ave
			public void durmir(){ //interface nao precisa do public ja na implementação precisa
			}
			public void voar(){ //interface nao 	precisa do public ja na implementação precisa
			}
		}
		
Class Scanner -  import java.util.Scanner //receber entrada externa 
			Scanner ler = new Scanner(System.in)
			Sting texto = ler.nextLine(); //recebe o texto digitado
			int numero = ler.nextInt();//somente numero inteiro
			double numero = ler.nextDouble();//recebe com "," e retorna com "."
			boolean text = ler.nextBoolean();
			
Class JOptionPane -	import javax.swing.JOptionPane; //caixa de dialogo grafica identico messageBox	
			JOptionPane.showMessageDialog(null,"ola mundo");// (posição em relaçao ao pai , text)
			//retorno de dados
			String nome = JOptionPane.showInputDialog("Qual seu nome?");
			int nome = JOptionPane.showConfirmDialog(null,"Voce e casado?"); //opção sim =0 nao=1 cancelar=2  fechar=-1
			
			
37 Try catch, throws tratamento	
             
			1)	try{//expressao pode ocorrer erro 
				}catch(Exception erro){ //(Exception erro) captura todo tipo de excessão
			    }
		      
			  //pode ter varios catch 
			2)	try{//expressao pode ocorrer erro 
				}catch(InputMismatchException erro){ //(troca  Exception erro) pela excessão especifica 
			         //InputMismatchException - entrada de valor do tipo incorreto
					JOptionPane.showMessageDialog(null,"Voce só pode informar numeros inteiros!");
				}catch(ArithmeticException erro){ //(troca  Exception erro) pela excessão especifica 
			         //ArithmeticException - divisao por zero
					 System.out.print("Nenhum numero pode ser dividido por zero")
					 
				} finally{   // independente se ocorrer erro vai ser executado qundo precisa fechar algo arquivo ou banco de dados
					System.out.print("Fim")
				}
				
			3) e.getMessage  //pega a msg que vc passou 
			   e.printStackTrace //fala onde o erro ocorreu
			   
			4) throws   //usado quando os erros for tratados dentro de uma class
			DECLARAÇÃO DO METODO
				public static double pegarNumero() throws Exception{
					//obriga colocar tratamento quando for chamar o metodo try cath
				}
			 DENTRO DO METODO 
				if(2==2){
					new throws 
				}
			   
			   
38 converte conversão dados				
				
		  string para inteiro   ex:  int x = Integer.parseInt("27");
          string para double    ex:  double x = Double.parseDouble("3.65"); 
          string para boolean   ex:  boolean x = Boolean.parseBoolean("true"); 
          converter para string ex:  String x = String.valueOf(1);
		   BigDecimal x  = BigDecimal.valueOf(9);
		   
	BigDecimal arredondar casas decimal	 

		valor.setScale(2,BigDecimal.ROUND_HALF_EVEN);  //arredonda automatico >5 para cima <= 5 para baixo
		valor.setScale(2,BigDecimal.ROUND_HALF_UP);    //arredonda para cima o >=5
		valor.setScale(2,BigDecimal.ROUND_HALF_DOWN); //arredonda para baixo o <=5
		valor.setScale(2,RoundingMode.FLOOR);         // truncar valor 
		
		 
		//não arredonda truncando pega valor e deixa como esta sem arredondar
					DecimalFormat decimalFormat = new DecimalFormat("#,##0.00");
			        decimalFormat.setRoundingMode(RoundingMode.DOWN);
			        String str = decimalFormat.format(valor).toString();
			        str = str.replace(".","");
			        str = str.replace(",", ".");
			        str = str.trim();
			        valor =  new BigDecimal(str) ;

39 Separa Split - nao funciona com $

	1)		String nome = "Heliton Silva Vieira";
            String[] nomes = nome.split(" "); //split cria um vetor separando (" ") pelo campo determinado no parentes
			System.out.print(nomes[1]);//Heliton
			System.out.print(nomes[2]);//Silva
			System.out.print(nomes[3]);//Vieira

    
	2)		String nome = "Heliton Silva Vieira";
            String[] nomes = nome.split(" ",2); //(" ",2) determina quantas parte quer separar
			System.out.print(nomes[1]);//Heliton
			System.out.print(nomes[2]);//Silva Vieira
    
	
	3)  Fazendo uma soma 

		int soma = calc.somar("1+1+3"); //passa string 
		
		public int somar(String expressao){
		int soma = 0;
		for(String valorSomar : expressao.split("\\+"))
			soma += Integer.valueOf(valorSomar);			
		
		System.out.println(soma);
		return soma;	//retorna valor da soma
	}

-----------------------USO VAR ARRAYS ...
		
		soma(10,25,30,2,4)//chamada metodo
		
		//...possibilita receber varios valores 
		public int somar(int ...valores){
			int soma =0;
			for (int valor :valores){
				soma += valor
			}
			return soma;
		}

---------------------------------------------	
40) Replace altera texto
              nome.replace("antigo","novo");	
              nome.replaceFirt("antigo","novo");//altera só a primeira ocorencia que encontrar

41)Length - tamanho String  
			  nome.length()

42) JFrame - Formulario janela grafica import javax.swing.JFrame

		public class Formulario{
     		JFrame jf = new JFrame();
			jf.setTitle("Titulo da janela");
			jf.setSize(500,400);//tamanho em px
            jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//obrigatorio para quando fechar a janela no ficar ocupando espaço memoria
			jf.setLocationRelativeTo(null);//centralizar a janela
			jf.setResizable(false); //nao redimencionar a janela tamanho
			jf.setVisible(true);//deixar janela visivel
            }

    tambem pode ser escrito como herança
		
		public class Formulario extends JFrame{
     		
			setTitle("Titulo da janela");
			setSize(500,400);//tamanho em px
            setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//obrigatorio para quando fechar a janela no ficar ocupando espaço memoria
			setLocationRelativeTo(null);//centralizar a janela
			setResizable(false); //nao redimencionar a janela tamanho
			setVisible(true);//deixar janela visivel
            }


43) adicionar botao ao formulario
              	
	public class Formulario extends JFrame{
     		
		JButton jb = new JButton("Botao 1");
		public botao(){	
		  
		  setLayout(null); //eu quero controlar meus conpomentes
		  jb.setBounds(10,20,100,60)//(x,y,alt,larg)(posiçaoHorizontal,posiçaoVertical,altura,largura)
   		  //getContentPane().add(jb);   //só para resaltar que o botao esta dentro de um getContentPane
			add(jb);
			setTitle("Titulo da janela");
			setSize(500,400);//tamanho em px
            setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//obrigatorio para quando fechar a janela no ficar ocupando espaço memoria
			setLocationRelativeTo(null);//centralizar a janela
			setResizable(false); //nao redimencionar a janela tamanho
			setVisible(true);//deixar janela visivel
        }
	}		

        //main chama o metodo botao
		new botao();

ArrayList - nao aceita tipo primitivo tipo int double somente String Integer 
            vantagem nao precisa ser informado a qtde de posição inicial
		
		ArrayList<String> nomes = new ArrayList<Sting>();
		nomes.add("gugu");
		nomes.add("boi");
		nomes.remove(0);
		nomes.clear(); //remove todas as posicao
		nomescontains("gugu"); // retorna true verifica se exist no array 
		nomes.size(); // tamanho quantas posiçao preenchida
		nomes.indexOf("boi"); //retorna posiçao que o obj encontra se nao encontrar retorna -1
		
		pegar valor 
			nomes.forEach(i -> System.out.print(i.getNome()))
			
			ou
			
			nomes.forEach(nome -> {
				//pode colocar as condições if 
				System.out.print(nome); 
			})
			
			
			List<ItemVenda> itens = IntStream
				.range(0,2) //incluir 2 item
				.mapToObj( value -> ItemVenda.builder()
							.id(1)
							.nome("vaca tolada")
							.build())
				.collect(Collectors.toList());
				
=======================================================
Funções LAMBDA
=======================================================		
SAM simple abstract metodo 
Lambda uma classe abstrata com um unico metodo que pode ser abreviado ex: Runnable e ActionListener

LAMBDA      (argumento)-> implementação do metodo
             ()-> System.out.println("Ola mundo");

ex 1 LAMBDA:  Runnable

		new Thread(new Runnable() {
			@Overridepublic void run() {
				System.out.println("Ola mundo");
			}
		
		}).run();
		
Pode ser assim	
	
		new Thread(() -> System.out.println("Ola mundo")).run();
		
		
Usando a expressão lambida este msm codigo ficaria 

		new Thread(() -> System.out.println("Ola mundo")).run();
		
ex 2 LAMBDA:  ActionListener

        JButton jButton = new JButton();
		jButton.addActionListener(new ActionListener(){
			@Override
			public void actionPerformed(ActionEvent e ){
				System.out.println("Ola mundo");
			}
		
		});
		
		
Pode ser assim:
	
	JButton jButton2 = new JButton();
	jButton2.addActionListener( e -> System.out.println("Ola mundo"));
	
=======================================================
Funções Stream 
=======================================================	

Trabalhar com Arrays List
	
	List<Integer> lista = Arrays.asList(1,5,8,9,1,4,7,6,9,9);
1)	
	for(Integer x : lista){
	  System.out.println(x);
	}
	
	Usando o stream 
	
	lista.stream().forEach(e -> System.out.println(e));
	
2) .skip(2)   Pular elementos do inicio no caso 2 primeiros nao iriam imprimir

	lista.stream()
	.skip(2) 
	.skip(1)     //Pode ter mais de 1
	.forEach(e -> System.out.println(e));
	
2) .limit(2)   busca elementos do inicio no caso 2 primeiros nao iriam imprimir

	lista.stream()
	.limit(2) 	 
	.forEach(e -> System.out.println(e));
	
3) .distinct()   // retira os elementos repetidos 

4) .filter()   //vc pode criar seu proprio filtro

	lista.stream()
	.filter( e -> e%2 == 0)  //buscar somente os numeros pares	 
	.forEach(e -> System.out.println(e));
	

4) .map()   //manipular e transformar os elementos 

	lista.stream()
	.map( e -> e * 2)  //pega todos da lista e multiplica por 2  nao muda a lista original somente que vai imprimir no forEach
	.forEach(e -> System.out.println(e));
	
5) retornos final 

	long count = lista.stream()
				.filter( e -> e % 2 == 0)  //contar todos os pares
				.count();
				
6)min e max

		Optional<Integer> min = lista.stream()
								.filter( e -> e % 2 == 0)  // todos os pares
								.min(Comparator.naturalOrder());  // tem que usar o Comparator
								
		Optional<Integer> min = lista.stream()
								.filter( e -> e % 2 == 0)  // todos os pares
								.max(Comparator.naturalOrder());  // tem que usar o Comparator	

7) .collect  // retorno customizados 

		List<Integer> novaList = lista.stream()
								.filter( e -> e % 2 == 0)  // todos os pares
								.collect(Collectors.toList());      // .toList armazenar os valores na nova lista	     


  Este ideal para agrupar por idade , endereço, 	
		Map<Boolean, List<Integer>> novaList = lista.stream()
		                                       .collect(Collectors.groupingBy(e -> e % 3));  // separa em true os que sao divisiveis por 3 
								

   joining agrupar strings 
				String collect = lista.stream()
				.map(e -> String.valueOf(e))
				.collect(Collectors.joining(";"));  vai juntar todos os numeros e separar por ;
				
				
=======================================================
public static List<CadastroOcorrencia89ResponseDTO> entidadeParaDto(List<YMTJW82SResponseAreaSaidaFuncaoTj89Ocorr89> lista) {

		List<CadastroOcorrencia89ResponseDTO> listaDTO = new ArrayList<>(0);

		lista.forEach(l -> {
			// pegar somente quanto tiver valores
			if (l.getCrBanco89() > 0) {
				listaDTO.add(CadastroOcorrencia89ResponseDTO.builder()
						.banco(l.getCrBanco89())
						.agencia(l.getCrAgencia89())
						.conta(l.getCrConta89())
						.digito(l.getCrDigito89())
						.tipoConta(l.getCrTipoCta89())
						.nome(l.getCrNome89())
						.rcodeConta(l.getRcodeCta89())
						.codMsg(l.getCodMsg89())
				        .codMsgGmsg(l.getCodMsgGmsg89())
						.build());
			}
		});

		return listaDTO;

	}	

	
		AVANÇADO PASSAR VARIOS ENDEREÇOS PARA UM CLIENTE E TAMBEM CONSEGUE QUE FAZER COM QUE O CLIENTE RECEBA VARIOS ENDEREÇOS
		
		@Getter
        @Setter
        @ToString
        @Builder
        @NoArgsConstructor
        @AllArgsConstructor
		
		public class Cliente { 	
			private String nome ; 
			private List<Endereco> endereco = new ArrayList<>();
		}
		----------
		@Getter
        @Setter
        @ToString
        @Builder
        @NoArgsConstructor
        @AllArgsConstructor	
		
		public class Endereco { 	
			private String rua ; 
			private Integer numero;
			private String bairro;
			
		}
        ----------
         public class ClienteMapper {
         
             public Cliente retornoComVariosEndereco(Cliente response) {           	
         		
             	
                 return ConsultaContaCadastradaResponseDTO.builder()
                 		.nome(getDebNome83())                 		
                        .enderecos(EnderecosMapper.entidadeParaDto(response.getEnderecos()))
                        .build();        		 
                 		          
             }
         }
		----------	
		
	    public class EnderecosMapper { 	 

            public static List<Endereco> entidadeParaDto(List<Endereco> lista) {
            
            	List<Cliente> listaDTO = new ArrayList<>(0);
            
            	lista.forEach(l -> {
            		// if caso nescessario
            		if (0 == 0 ) {
            			listaDTO.add(Cliente.builder()
            					.rua(l.getRua())
            					.numero(l.getNumero())
								.bairro(l.getBairro())
								.build());
            		}
            	}
            
            	);
            
            	return listaDTO;
            
	   }
	   ---------

		
	

data date  https://docs.oracle.com/javase/8/docs/api/java/util/Date.html
        Bibliotecas 
			jdk 8 - import java.text.SimpleDateFormat;
				@JsonFormat(pattern="dd/MM/yyyy HH:mm")
				private Date instante;
				
		/*metodo que adicionar dias no java 8 */
		public static String addDiasDate(String dtaInicio, int qtdDias) { // dtaInicio tem que ser dd/mm/yyyy OU dd.mm.yyyy
    	
    	dtaInicio = dtaInicio.replace(".", "/");
    	
		DateTimeFormatter parser = DateTimeFormatter.ofPattern("dd/MM/uuuu")
			    .withResolverStyle(ResolverStyle.STRICT); //para não aceitar data invalida tipo 31/02/2022
		LocalDate data = LocalDate.parse(dtaInicio, parser);
		LocalDate dtaAtual = data.plusDays(qtdDias);
		
		return String.valueOf(dtaAtual); //retorno aaaa-mm-dd
    }
	
	
			
			jdk 11- import java.time.LocalDateTime; 
				@JsonFormat(pattern="dd/MM/yyyy HH:mm")
				private LocalDateTime dtaAdmissao; 
		

		Date data = new Date();
		SimpleDateFormat formatar = new SimpleDateFormat("dd/MM/yyyy");
		String dataFormatada = formatar.format(data);
		ctrol+v // para ver os SimpleDateFormat existentes


Sleep - espera um tempo para executar  proximo comando 

		try{
		Thread.sleep(1000); // leva 1000 milessegundo ou 1 segundo para executar proximo comando 
         }catch(Exception erro){}


--------------------------------StringBuilder (juntar string quando texto muito grande)------------------------------------------------------------------------

public String toString() {
		StringBuilder builder = new StringBuilder();
		builder.append("Produto: ");
		builder.append(getNome());		
		builder.append(", Preço: ");
		builder.append(getPreco());	
		return builder.toString();
	}

-------------------------------------------------------------------------------------------------------
Coleções collections (listas,conjuntos,mapas)
-------------------------------------------------------------------------------------------------------
List = generico mantem a ordem de inserção    ArrayList<String> itens = new ArrayList<>();
Set = não aceita registro duplicado, ele não é ordenado   Set<String> itens = new HashSet<>();
   HashSet = nao mantem ordem de inserção        Set<String> itens = new HashSet<>();
   LinkedHashSet = mantem ordem de inserção      Set<String> itens = new LinkedHashSet<>(); 
Map = chave, valor     Set<String, Pessoa> itens = new HashMap<String,Pessoa>();


Hierarquia 1 (de forma simplificado com mais usados )


                                         ---- Set<E> ---- LinkedHashSet<E>
	iterable<E> ------ Collection<E> ---- List<E>
					 ---- Queue<E>


Hierarquia 2 (de forma simplificado com mais usados )

		  ---- AbstractMap<K,V> ---- HashMap<K,V> ---- LinkedHashMap<K,V>
        Map<k,V> 
		  ---- SortdMap<K,V>  ---- NavigableMap<K,V> ---- TreeMap<K,V>
		  
---		  
ArrayList (tipo generico)
	
	1 - Simples
	    String i1 = "uva"
	    String i2 = "pera"
	    String i3 = "vaca"
	    
	    ArrayList<String> itens = new ArrayList<>(); // declaração 
	
	2 - Vetor
	    String[] nomeItens = {uva,pera,vaca}
	    
	     ArrayList<String> itens = new ArrayList<String>(Arrays.asList(nomeItens));
	    
	
	itens.add(i1);
	itens.add(i2);
	itens.add(i3);
	
	system.out.print(itens); //retorno  [uva,pera,vaca]

    metodos 
	itens.remove(0);
	itens.get(0); //pegar primeira aula 
	itens.size(); //qts elementos tem na coleção
	Collections.sort(itens) // ordena ordem alfabetica

   Percorer a coleção	
	for (String item : itens ){
		system.out.print(item); 
	}

   ou

	for (int i = 0; i < itens.size(); i++ ){  // se colocar <= vai estourar e gerar erro no java
		system.out.print(itens.get(i)); 
		
		if (qtdDia > itens.get(indicador).getqInicAliqtIof() && qtdDia < itens.get(indicador).getqFimAliqtIof()) {
				break;
			}
	}
	
   ou 
        itens.forEach(item ->{item})  //para cada item dentro do itens -> faça {System.out.print()}		
----
Set(não aceita item duplicado e não é ordenado)

	Produto p1 = new Produto(1,"mesa",1.5);
	Produto p2 = new Produto(1,"cadeira",3.5);
	Produto p3 = new Produto(1,"prato",2.5);
	
	Set<Produto> produtoSet = new HashSet<>();
	produtoSet.add(p1);
	produtoSet.add(p2);
	produtoSet.add(p3);
	
	for(Produto p : produtoSet){
	   System.out.println(p);
	}

LinkedHashSet (para garantir a ordem que foi encerido)
	Set<Produto> produtoSet = new LinkedHashSet<>();	

HashSet (Manipulação de conjunto)

	ex: conjunto de 3 progamadores onde 1 sabe java ou tor php e outro sabe as duas linquagem
	
	   HashSet<Pessoa> sabeJava = new HashSet<Pessoa>();
	   sabeJava.add('Joao');
	   sabeJava.add('Maria');
	   
	   HashSet<Pessoa> sabePhp = new HashSet<Pessoa>();
	   sabeJava.add('Pedro');
	   sabeJava.add('Maria');
	   
	Interseção (pegar o elemento que contem nos dois)
	
	   HashSet<Pessoa> sabeJavaEPhp = new HashSet<Pessoa>(sabeJava); // pegando as pessoas que sabe java
	   sabeJavaEPhp.retainAll(sabePhp) // interseção que sabem java e php
	   
	   for (Pessoa p : sabeJavaEPhp ){
		system.out.println(p);  //Maria
	   }
	
	Diferença (pessoas que sabem somente java e não sabe php)   
	   
	   HashSet<Pessoa> sabeJavaEPhp = new HashSet<Pessoa>(sabeJava); // pegando as pessoas que sabe java
	   sabeJavaEPhp.removeAll(sabePhp) // diferença que sabem java
	   
	   for (Pessoa p : sabeJavaEPhp ){
		system.out.println(p);  //Maria
	   }

HashMap (chave valor) recuperação rapida do valor

	 HashMap<String,Pessoa> mapa = new HashMap<String,Pessoa>();
	 mapa.put("10","Joao")
	 mapa.put("20","Maria")
	 mapa.put("30","Paulo")
	 
	 Pessoa alguem = mapa.get("20");  //alguem recebe Maria
	 
	 
	 EX:        HttpHeaders header = new HttpHeaders();
				
				for (Map.Entry<String, String> entry : headers.entrySet()) {
				   
					System.out.println(entry.getKey() + "/" + entry.getValue());
				    
					header.add(entry.getKey(), entry.getValue());
				}
					


LinkedHashMap (para garantir a ordem que foi encerido)
	
	HashMap<String,Pessoa> mapa = new LinkedHashMap<String,Pessoa>();
	
	
Ordenação Ordem (criar classe para ordenar crescente decrescente) usa implements comparable

	public class PessoaPorPeso implements Comparable{
	   
	   String nome;
	   float peso;
	   float altura;
	   
	   @Override
	   public int compareTo(Object arg0){
	      PessoaPorPeso p = (PessoaPorPeso) arg0;
	      
	      return(int) (this.peso - p.peso)*100 // forma crescente *100 para trabalhar com casa decimali
	                 //(p.peso - this.peso) caso seja decrescente
	   }
	}


Ordenação atraves de metodo Comparator

	public static Comparator<Pessoa> PesoComparator = new Comparator<Pessoa>(){
	   
	   public int compare(Pessoa p1, Pessoa p2){
	      return (int) (p1.peso*100 - p2.peso*100)
	   }
	};
	
	public static Comparator<Pessoa> AlturaComparator = new Comparator<Pessoa>(){
	   
	   public int compare(Pessoa p1, Pessoa p2){
	      return (int) (p1.altura*100 - p2.altura*100)
	   }
	};
  
  //ordena ordem alfabetica 	
	public static Comparator<Pessoa> NomeComparator = new Comparator<Pessoa>(){
	   
	   public int compare(Pessoa p1, Pessoa p2){
	      return p1.nome.compareTo(p2.nome); // p2.comparTo(p1) para decrescente
	   }
	};

   //utilizar os metodos criados 
   
	ArrayList<Pessoa> pessoas = new ArrayList<Pessoa>(); //popular lista com pessoas 
	Collections.sort(pessoas , Pessoa.PesoComparator); // ordenar por peso
	Collections.sort(pessoas , Pessoa.AlturaComparator); // ordenar por altura
	Collections.sort(pessoas , Pessoa.NomeComparator);  // ordena por nome
	


	
------------------ITERATOR----------------------------------

Iterator <String> lista = itens.iterator(); // pega todos itens e joga na lista 

while (lista.hasNext()){   //hasNext retorna true enquanto existe item na lista
	system.out.print(lista.next); // next funciona como o get	
	lista.remove // deletar 
}

---------------------------implements Serializable serializar -------------------------------------------------
implements Serializable = converter a classe em bits para trafegar em rede 
		ex: public class User implements Serializable {
			    private static final long serialVersionUID = 1L;

#############################################
Tratamento de Erros Exception 
#############################################
arvore		
			________Throwable__________
			|                          |
		___Exception___   		Error______
		|	       |			  |	
  InterruptedException   RuntimeException  	      ThreadDeath
		      _________|____________	
		     |  	            |		      
	ArithmeticException           NullPointerException
	
	
	
	try {
		//codigo fonte que sera verificado	
	}catch (){
		throw new AcessoADadosException("Problema na criação do statement",e);
	}finally{
		stmt.close(); //muito usado para finalizar conecxao com banco 
	}

	
	Throw e Throws (usado para excessão desejada em metodos)

			public String recuperarUsuario(String query) throws Acesso ADadosException{
				try {
					//codigo fonte que sera verificado	
				}catch (){
					throw new AcessoADadosException("Problema na criação do statement",e);
				}finally{
					stmt.close(); //muito usado para finalizar conecxao com banco 
				}
			}
			
			
#############################################
JPA
#############################################
Outros problemas que devem ser tratados:
	- Contexto de persistência (objetos que estão ou não atrelados a uma conexão em um dado momento)
	- Mapa de identidade (cache de objetos já carregados)
	- Carregamento tardio (lazy loading)
	- Outros


	Java Persistence API (JPA) é a especificação padrão da plataforma Java EE (pacote javax.persistence) para
	mapeamento objeto-relacional e persistência de dados.
	JPA é apenas uma especificação (JSR 338):
	http://download.oracle.com/otn-pub/jcp/persistence-2_1-fr-eval-spec/JavaPersistence.pdf
	Para trabalhar com JPA é preciso incluir no projeto uma implementação da API (ex: Hibernate).
	Arquitetura de uma aplicação que utiliza JPA:
	Principais classes:
	EntityManager
	
-----------------------------------------
EntityManager - Documentação  https://docs.oracle.com/javaee/7/api/javax/persistence/EntityManager.html
----------------------------------------
	EntityManager encapsula uma conexão com a base de dados e serve para efetuar operações de
		acesso a dados (inserção, remoção, deleção, atualização) em entidades (clientes, produtos, pedidos, etc.)
		por ele monitoradas em um mesmo contexto de persistência.

		Escopo: tipicamente mantem-se uma instância única de EntityManager para cada thread do sistema (no caso
		de aplicações web, para cada requisição ao sistema).
		EntityManagerFactory
		

-----------------------------------------
EntityManagerFactory - https://docs.oracle.com/javaee/7/api/javax/persistence/EntityManagerFactory.html
-----------------------------------------		
Um objeto EntityManagerFactory é utilizado para instanciar objetos EntityManager.
Escopo: tipicamente mantem-se uma instância única de EntityManagerFactory para toda aplicação.



3) Configure o JPA no seu projeto por meio do arquivo persistence.xml
 Crie uma pasta "META-INF" a partir da pasta "src"
 Dentro da pasta META-INF crie um arquivo "persistence.xml"
 Conteúdo do arquivo persistence.xml:


<?xml version="1.0" encoding="UTF-8"?>
<persistence xmlns="http://xmlns.jcp.org/xml/ns/persistence"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence
http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd"
version="2.1">
<persistence-unit name="exemplo-jpa" transaction-type="RESOURCE_LOCAL">
<properties>
	<property name="javax.persistence.jdbc.driver" value="com.mysql.jdbc.Driver" />
<property name="javax.persistence.jdbc.url" value="jdbc:mysql://localhost/aulajpa" />
<property name="javax.persistence.jdbc.user" value="root" />
<property name="javax.persistence.jdbc.password" value="" />
<property name="hibernate.hbm2ddl.auto" value="update" /> /*faz as atualização sempre no banco create recria toda vez o banco */
</properties>
</persistence-unit>
</persistence>



4) Inclua os MAPEAMENTOS na classe de domínio:
package dominio;
import (...)
@Entity
public class Pessoa implements Serializable {
private static final long serialVersionUID = 1L;
@Id
@GeneratedValue(strategy=GenerationType.IDENTITY)
private Integer id;
(...)


#############################################
package domain jpa
#############################################

https://www.youtube.com/watch?v=d_5iZJ8p9x8&list=PLbA-jMwv0cuUp3UKlLHng6E-xgD037bXz&index=2

Mapeamento basico https://receitasdecodigo.com.br/hibernate/primeiros-passos-para-mapear-uma-tabela-simples-com-hibernate
	@Entity  //informar que e um mapeamento jpa
	@CodEmpresa // uso obrigatorio chave primaria
	@GeneratedValue(strategy = GenerationType.AUTO)  // alto incremento
	@Table(name="USUARIO") // determinar o nomEmpresa que sera usado no banco
	@Column(name="cod_pessoa") // nomEmpresa coluna no banco de dados

Chave composta  https://receitasdecodigo.com.br/hibernate/chaves-compostas-com-hibernate
	@CodEmpresaClass(EmpresaCodEmpresa.class)   // Quando mais de 1 @CodEmpresa para definir qual
	@Embeddable //Quando vc cria outra classe mais todos os atributos vai ser visto na classe que vc coloca o @Embeddable
	              Deixa a classe mais limpa 
		      tem que colocar a anotação na classe referenciada tbm
		      ex: classe Cliente(cod, nome) com Endereco(rua,bairro,cidade,estado,pais) na classe (cliente) coloca parametro
				
				@Embeddable
				private Endereco
		     SERIA COMO SE TUDO QUE TEM NA CLASSE ENDEREÇO ESTIVESSE NA CLASSE CLIENTE
                      cria uma classe para informar os codEmpresas (Segundo autor prefercodEmpresaa)

-------------------------	
Muitos para um https://receitasdecodigo.com.br/hibernate/hibernate-manytoone-muitos-para-um-com-objeto-relacional
exemplo:1(	Mapeando a tab_item_pedcodEmpresao 

            @ManyToOne(fetch = FetchType.EAGER,  cascade=CascadeType.ALL)    //FetchType.EAGER (garante que a coleção vem junto na busca)
			@JoinColumn(name="cod_item")   //define qual coluna é responsável pela ligação entre os objetos.
			private Item item; )
	
	//FetchType.EAGER, carrega automatico tabela refereciada ex: tab_item_pedcodEmpresao e a tab_item
	//FetchType.LAZY,carrega com comando programador ex: so traz a tab_item_pedcodEmpresao
	// cascade tipo de relacionamento
	
//Mapeando a tab_item			
			@OneToMany(mappedBy = "item", cascade = CascadeType.ALL, fetch = FetchType.EAGER)
			private Set<NomClasseItemPedcodEmpresao> lsNomClasseItemPedcodEmpresao;
------------------------------------------		

Coleções @ElementCollection
		
	@ElementCollection
	@CollectionTable(name="TELEFONE")
	private Set<String> telefones = new HashSet<>();
------------------------------------------------
categoria e produto caso nao haja o categoriaDTO tem que fazer um tratamento 
1)do lado da categoria deve informar 
	@JsonMapagedReference   // anotaçao pacote jackson associando os item a categoria 
	@ManyToMany(mappedBy="categorias")
	private List<Produto> produtos = new ArrayList<>();
	
2) do lado do item ou produto deve informar	
    @JsonBackReference //informa que do outro lado ja foi buscado ai nao busca mais 
	private List<Categoria> categorias = new ArrayList<>();
	
	

-----------------------------------------------

package com.helitonvieira.helisistema.domain;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import javax.persistence.CascadeType;
import javax.persistence.CollectionTable;
import javax.persistence.Column;
import javax.persistence.ElementCollection;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.CodEmpresa;
import javax.persistence.OneToMany;
TipoCliente;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.helitonvieira.helisistema.domain.enums.Perfil;
import com.helitonvieira.helisistema.domain.enums.

@Entity
public class Cliente implements Serializable {
	private static final long serialVersionUID = 1L;

	@CodEmpresa
	@GeneratedValue(strategy=GenerationType.IDENTITY)
	private Integer codEmpresa;
	private String nomEmpresa;
	
	@Column(unique=true)
	private String email;   
	private String cpfOuCnpj;
	private Integer tipo;
	
	@JsonIgnore
	private String senha;
	
	@OneToMany(mappedBy="cliente", cascade=CascadeType.ALL)
	private List<Endereco> enderecos = new ArrayList<>();
	
	@ElementCollection
	@CollectionTable(name="TELEFONE")
	private Set<String> telefones = new HashSet<>();
	
	@ElementCollection(fetch=FetchType.EAGER)
	@CollectionTable(name="PERFIS")
	private Set<Integer> perfis = new HashSet<>();
	
	@JsonIgnore  
	@OneToMany(mappedBy="cliente")
	private List<PedcodEmpresao> pedcodEmpresaos = new ArrayList<>();
	
	public Cliente() {
		addPerfil(Perfil.CLIENTE);
	}
	


	public Cliente(Integer codEmpresa, String nomEmpresa, String email, String cpfOuCnpj, TipoCliente tipo, String senha) {
		super();
		this.codEmpresa = codEmpresa;
		this.nomEmpresa = nomEmpresa;
		this.email = email;
		this.cpfOuCnpj = cpfOuCnpj;
		this.tipo = (tipo==null) ? null : tipo.getCod();
		this.senha = senha;
		addPerfil(Perfil.CLIENTE);
	}

	public Integer getCodEmpresa() {
		return codEmpresa;
	}

	public vocodEmpresa setCodEmpresa(Integer codEmpresa) {
		this.codEmpresa = codEmpresa;
	}

	public String getNomEmpresa() {
		return nomEmpresa;
	}

	public vocodEmpresa setNomEmpresa(String nomEmpresa) {
		this.nomEmpresa = nomEmpresa;
	}

	public String getEmail() {
		return email;
	}

	public vocodEmpresa setEmail(String email) {
		this.email = email;
	}

	public String getCpfOuCnpj() {
		return cpfOuCnpj;
	}

	public vocodEmpresa setCpfOuCnpj(String cpfOuCnpj) {
		this.cpfOuCnpj = cpfOuCnpj;
	}

	public TipoCliente getTipo() {
		return TipoCliente.toEnum(tipo);
	}

	public vocodEmpresa setTipo(TipoCliente tipo) {
		this.tipo = tipo.getCod();
	}

	public String getSenha() {
		return senha;
	}
	
	public vocodEmpresa setSenha(String senha) {
		this.senha = senha;
	}
	
	public Set<Perfil> getPerfis() {
		return perfis.stream().map(x -> Perfil.toEnum(x)).collect(Collectors.toSet());
	}
	
	public vocodEmpresa addPerfil(Perfil perfil) {
		perfis.add(perfil.getCod());
	}
	
	public List<Endereco> getEnderecos() {
		return enderecos;
	}

	public vocodEmpresa setEnderecos(List<Endereco> enderecos) {
		this.enderecos = enderecos;
	}

	public Set<String> getTelefones() {
		return telefones;
	}

	public vocodEmpresa setTelefones(Set<String> telefones) {
		this.telefones = telefones;
	}

	public List<PedcodEmpresao> getPedcodEmpresaos() {
		return pedcodEmpresaos;
	}

	public vocodEmpresa setPedcodEmpresaos(List<PedcodEmpresao> pedcodEmpresaos) {
		this.pedcodEmpresaos = pedcodEmpresaos;
	}
	
	@OverrcodEmpresae
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((codEmpresa == null) ? 0 : codEmpresa.hashCode());
		return result;
	}

	@OverrcodEmpresae
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Cliente other = (Cliente) obj;
		if (codEmpresa == null) {
			if (other.codEmpresa != null)
				return false;
		} else if (!codEmpresa.equals(other.codEmpresa))
			return false;
		return true;
	}
}

#############################################	
INJEÇÃO DE DEPENDENCIA 
#############################################
	@Component @Controller @Service @Repository 
	Estas anotações vc esta informando para o Spring que ele vai gerenciar as instancia da classe podendo usar o @Autowired
	
	@Autowired	// Função do New ai nao precisa usar new, o Spring gerencia a instancia	
	
	@Bean  Usado para informar que o spring vai gerenciar instancia de classe externa projetos fora do nosso
		Colocar a dependencia do projeto externo
		E preciso criar a config no pacote config 		
		ex:  
		        @Bean
			public EmailService emailService() {
			   return new SmtpEmailService();
			}
	
		ex2: 
            @Configuration    // Importante usar dizer quando estarta a app ja carrega as variaveis 
			public class Configuracao {
			
        	  @Bean("gol")
			  public Carro gol(){
					Carro carro = new Carro();
					carro.setAno(2024);
					carro.setCor("Branco");
					
					return carro;
			 }
			 
			  @Bean("Polo")
			  public Carro polo(){
					Carro carro = new Carro();
					carro.setAno(2024);
					carro.setCor("Verde");
					
					return carro;
			 }
		
		
		buscando 
			@Autowired
			@Qualifier("gol")
			private Carro carro;
	
#############################################
package resources ou cotrollers 
#############################################

 @Component @Controller @RestController  (descreve um endpoint que deve ser disponibilizado na web)
	1) a ser criado @Component
	2) a ser criado @Controller veio com tudo que  o @Component tem e mais 
	3) a ser criado @RestController veio com tudo que  o @Controller tem e mais 

@Autowired
	@Autowired	// Função do New ai nao precisa usar new, o Spring gerencia a instancia	
	private EmpresaRepository repository;
	
@RequestMapping(method = RequestMethod.GET, value="/empresa")  ou  @GetMapping("/empresa")
	  //mapeamento request recebendo da tela 
	  //method = RequestMethod.GET, GET pela url

	@GetMapping("/hello")
	public String hello(@RequestParam(value = "name", defaultValue = "Heliton") String name) {
	return String.format("Hello %s!", name);
	}
	//http://localhost:8080/hello?name=Juliana	
	//Esta esperando um nome na passagem de parametro mais se não passar por default pega Heliton

@RequestMapping(method = RequestMethod.POST, value="/empresa")  ou  @PostMapping("/empresa")	  
	  //method = RequestMethod.POST,POST oculto 
	  
	 -------------------------------------
	package com.vsystem.clienteSystem.controller;
	
-------------------------------------
ResponseEntity retorno resposta corretos http

GET  return ResponseEntity.ok(cliente); //ResponseEntity.ok  resposta status 200
GET  return ResponseEntity.notFound().build();	// resposta status 404 
POST return new ResponseEntity<>(response, HttpStatus.CREATED);
PUT  return ResponseEntity.ok(cliente); //ResponseEntity.ok  resposta status 200
DELETE return ResponseEntity.noContent().build();//retorna resposta status 204

-------------------------------------	

import java.util.List;
import java.util.Optional;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestController;

import com.vsystem.clienteSystem.domain.model.Cliente;
import com.vsystem.clienteSystem.domain.repository.ClienteRepository;

@RestController
@RequestMapping("/clientes")
public class ClientesController {
	
	@Autowired
	private ClienteRepository repo;	
	
	@GetMapping
	public List<Cliente> listar() {				
		return repo.findAll();
	}
	
	/*@GetMapping("/{nome}") // passando parameto pela url   localhost:8080/clientes/1
	public List<Cliente> listarNome(@PathVariable String nome) {	//@PathVariable receber o parametro		
		return repo.findByNome(nome);
	}
	
	@GetMapping("/{Like}")
	public List<Cliente> listarLike(@PathVariable String nome){
	    return repo.findByNomeContaining(nome);
	}*/
	
	@GetMapping("/{clienteId}")
	public ResponseEntity<Cliente> busca(@PathVariable Long clienteId){
		Optional<Cliente>cliente =	repo.findById(clienteId); // Optional muito usado pois pode ser que encontre ou não no banco 
		
		if (cliente.isPresent()) {  //.isPresent() = se tiver informação     .empty = vazio 
			return ResponseEntity.ok(cliente.get()); //ResponseEntity.ok  resposta status 200			
		}		
	    return ResponseEntity.notFound().build();	// resposta status 404   		
	}
	
	@PostMapping
	@ResponseStatus(HttpStatus.CREATED)// retornar a resposta  status 201 create 
	public Cliente adicionar(@RequestBody Cliente cliente) { // receber obj tipo cliente json  { "nome": "Leonardo de Caprio", "email": "leo@gmail.com", "telefone": "349999999999"}
		return repo.save(cliente);		
	}
	
	@PutMapping("/{idCliente}")
	public ResponseEntity<Cliente> atualizar(@RequestBody Cliente cliente, 
		@PathVariable Long idCliente) { // receber obj tipo cliente
		
		if(!repo.existsById(idCliente)) {  //verificando se existe este cliente
			return ResponseEntity.notFound().build();	//retorna resposta  status 404		
		}
		cliente.setId(idCliente);	
		cliente = repo.save(cliente);
		return 	ResponseEntity.ok(cliente); //retorna a resposta status  200
	}
	
	@DeleteMapping("/{idCliente}")
	public ResponseEntity<Void> delete(@PathVariable Long idCliente){
		
		if(!repo.existsById(idCliente)) {  //verificando se existe este cliente
			return ResponseEntity.notFound().build();			
		}
		
		repo.deleteById(idCliente);
		return ResponseEntity.noContent().build();//retorna resposta status 204
	}
	
	//Pegar informação do header cabecario cabeçario 
	public ResponseEntity<Cliente> calcular(@NotBlank @RequestBody ClienteRequestDTO body
		                                     ,@RequestHeader Map<String, String> headers) { //pegar os dados do headers
		 System.out.println("meu header" + headers );
		 System.out.println("HEADER x-stateless-open É: " + headers.get("x-stateless-open") );
}	



---------------------------------------------------------------------------------------------
.mostrar msg e rastreiar problemas

slf4j.Logger  https://www.youtube.com/watch?v=ChIy6-ySpPM
como trabalhar como logger no sistema e gerar arquivo de log


---------------------------------------------------------------------------------------------
INTRODUÇÃO AO modelmapper feramenta que facilica a conversao de model para modelDTO  
http://www.matera.com/blog/post/modelmapper-convertendo-objetos-de-maneira-simples

        <dependency>
			<groupId>org.modelmapper</groupId>
		  	<artifactId>modelmapper</artifactId>
		  	<version>2.3.7</version>
		</dependency>
		
		//abaixo tem exemplo claro metodo buscar e criar 
        
----------------------------------------------------------------------------------------------
package com.algaworks.osworks.api.controller;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

import javax.validation.Valid;

import org.modelmapper.ModelMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestController;

import com.algaworks.osworks.api.model.OrdemServicoInput;
import com.algaworks.osworks.api.model.OrdemServicoModel;
import com.algaworks.osworks.domain.model.OrdemServico;
import com.algaworks.osworks.domain.repository.OrdemServicoRepository;
import com.algaworks.osworks.domain.service.GestaoOrdemServicoService;

@RestController
@RequestMapping("/ordens-servico")
public class OrdemServicoController {

	@Autowired
	private GestaoOrdemServicoService gestaoOrdemServico;
	
	@Autowired
	private OrdemServicoRepository ordemServicoRepository;
	
	@Autowired
	private ModelMapper modelMapper; //ferramenta poderosa que auxilia a conversao de domain para dto 
	
	@PostMapping
	@ResponseStatus(HttpStatus.CREATED)
	public OrdemServicoModel criar(@Valid @RequestBody OrdemServicoInput ordemServicoInput) {
		OrdemServico ordemServico = toEntity(ordemServicoInput);
		
		return toModel(gestaoOrdemServico.criar(ordemServico));
	}
	
	@GetMapping
	public List<OrdemServicoModel> listar() {
		return toCollectionModel(ordemServicoRepository.findAll()); //chama funcao converte domain para model 
	}
	
	@GetMapping("/{ordemServicoId}")
	public ResponseEntity<OrdemServicoModel> buscar(@PathVariable Long ordemServicoId) { //OrdemServicoModel class dto 
		Optional<OrdemServico> ordemServico = ordemServicoRepository.findById(ordemServicoId);
		
		if (ordemServico.isPresent()) {
			OrdemServicoModel ordemServicoModel = toModel(ordemServico.get());//chama metodo que converte o domainModel em dto 
			return ResponseEntity.ok(ordemServicoModel);
		}
		
		return ResponseEntity.notFound().build();
	}
	
	@PutMapping("/{ordemServicoId}/finalizacao")
	@ResponseStatus(HttpStatus.NO_CONTENT)
	public void finalizar(@PathVariable Long ordemServicoId) {
		gestaoOrdemServico.finalizar(ordemServicoId);
	}
	
	private OrdemServicoModel toModel(OrdemServico ordemServico) {//metodo que faz a conversao domain para dto 
		return modelMapper.map(ordemServico, OrdemServicoModel.class);
	}
	
	private List<OrdemServicoModel> toCollectionModel(List<OrdemServico> ordensServico) {//mudar uma lista domain para dto
		return ordensServico.stream()
				.map(ordemServico -> toModel(ordemServico))//.map aplica funcao a cada elemento como se fosse um for
				.collect(Collectors.toList()); 
	}
	
	private OrdemServico toEntity(OrdemServicoInput ordemServicoInput) {
		return modelMapper.map(ordemServicoInput, OrdemServico.class);
	}
	
}

--------------------------------------------------
 CORPO JSON
--------------------------------------------
class {} 
{
 "nome": "Leonardo de Caprio",
 "email": "leo@gmail.com",
 "telefone": "349999999999"
 "dtaPreVenda" : "2022-06-21T18:25:43-05:00" ,
}

CLASSE E LISTA 

public class IssueRemunerationRateDto {	
	
	private String nome;
	private String email;
	private List<TelefoneDto> telefone ;  // onde tem a class TelefoneDto com campos fone e contato

"Cliente": {
        "nome": "Leonardo de Caprio",
		"email": "leo@gmail.com",
        "telefone": [
                        {
                            "fone": "00000",
                            "contato": "Raquel" 
                        },
                        {
                            "fone": "11111",
                            "contato": "Jack" 
                        }
                    ] }
	
#############################################
VALIDAÇAO data inteiro e valor monetario 
#############################################	

package br.com.bradesco.brai.srv.motor.calculo.service;

import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.ResolverStyle;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import br.com.bradesco.brai.srv.motor.calculo.exception.BadRequestException;
import br.com.bradesco.brai.srv.motor.calculo.utils.Utils;

@Service
public class ValidacaoCampoService {

	@Autowired
	Utils utils;

	public void validaFormatData(String nomeCampo, String dta) {

		if (dta.length() == 10) {

			if (!dta.substring(4, 5).equals("-") || !dta.substring(7, 8).equals("-")) {
				throw new BadRequestException(400, nomeCampo,
						"Data tem que estar no formato YYYY-MM-DD, com 10 caracteres");
			}
			;

		} else {
			throw new BadRequestException(400, nomeCampo,
					"Data tem que estar no formato YYYY-MM-DD, com 10 caracteres");
		}

		try {

			dta = utils.conversorDataBrasil(dta);
			// dta = dta.replace("-", "/");

			DateTimeFormatter parser = DateTimeFormatter.ofPattern("dd/MM/uuuu")
					.withResolverStyle(ResolverStyle.STRICT);
			LocalDate dta1 = LocalDate.parse(dta, parser);

		} catch (Exception ex) {
			throw new BadRequestException(400, nomeCampo + "  Data informada não é uma data valída!", ex.getMessage());

		}

	}

	public void validaInteiro(String nomeCampo, String campo) {

		for (int i = 0; i < campo.length(); i++) {
			if (Character.isDigit(campo.charAt(i)) == false) {

				throw new BadRequestException(400, nomeCampo + " inválido",
						"Campo não informado. Campo com conteúdo inválido.");
			}

		}

	}

	public void validaValor(String nomeCampo, String campo) {

		for (int i = 0; i < campo.length(); i++) {
			if (Character.isDigit(campo.charAt(i)) == false) {
				if (!String.valueOf(campo.charAt(i)).equals(".")) {
					// if (!String.valueOf(campo.charAt(i)).equals(",")) {
					throw new BadRequestException(400, nomeCampo + " inválido",
							"Campo não informado. Campo com conteúdo inválido.");
					// }
				}

			}

		}

	}

}

	
#############################################
VALIDAÇAO (JAKARTA BEAN VALIDATION )  ele usa o pacote do javax.validation.constrants  https://www.baeldung.com/javax-validation
#############################################
	-------------------------------------------------------------
	Para o jdk11 tem que fazer esta implementação
	
	<!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-validator -->
			<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-validator</artifactId>
			<version>6.0.12.Final</version>
			</dependency>
	-------------------------------------------------------------		
	as validações sao feitas no domain modulo quando nao ha o dto se tiver dto sera feito no dto
	E tem que colocar @Valid no controller
	Ele trata o erro 500 do servidor e passa erro 400 que é do usuario
	
	OBS INT OU INTEGER NÃO ACEITA @NotEmpty  @NotBlank 
	
	@NotEmpty   //nao aceita vazio (nao aceita em int)
	@NotNull    //nao aceita nulo   
	@NotBlank   //nao aceita vazio nem nulo nem com somente espaço branco (nao aceita em int)
	@Email      //validação para email
	@Size(max = 20 min = 2)  // tamanho das colunas do banco para nao estourar
	@JsonIgnore    //para nao aparecer nao busca

    @JsonPropertyOrder({"cod","nome","valor"})	//Ordenar saida do json declara em cima da classe colocando os nomes dos atributos
	
	*****************de acordo com tipo *************************
	      @NotNull(message = "Name cannot be null")
          private String name;
	      
          @AssertTrue
          private boolean working;
	      
          @Size(min = 10, max = 200, message 
            = "About Me must be between 10 and 200 characters")
          private String aboutMe;
	      
          @Min(value = 18, message = "Age should not be less than 18")
          @Max(value = 150, message = "Age should not be greater than 150")
          private int age;
	      
          @Email(message = "Email should be valid")
          private String email;
    ******************************************
		
	no resouce deve ser informado no insert e no update 
	@Valid 
	ex:
		@PostMapping
			public Cliente adicionar(@Valid  @RequestBody ...
	
		
#############################################
flyway   // arquivos de configuração para o banco de dados  
#############################################	
1) seque o link para configuração
        https://github.com/npi-ufc-qxd/wiki/wiki/Guia-de-inser%C3%A7%C3%A3o-e-uso-do-Flyway-em-projetos-maven
	
2) dentro do pacote resource cria as pasta db/migration	
3) criar um arquivo dentro de migration criar um arquico   new/file/V001__criar-tabela-cliente.sql    obs o "V" maiusculo     //V001__criar-tabela-cliente.sql   o V001 é obrigatorio significa versao o nome depois aleatorio
4) sobre o arquivo click  btnDireito/Open With/text edit

OBS PROBLEMA APAGUE A TABELAS QUE FORAM CRIADAS TABELA FLYWAY TBM E AS SEQUENCES QUE FORAM CRIADAS 

#############################################
Service - responsavel pelas regras de negocio gerencia o cotrollers e o repository
#############################################	

package com.helitonvieira.helisistema.services;

import java.awt.image.BufferedImage;
import java.net.URI;
import java.util.List;
import java.util.Optional;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort.Direction;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;

import com.helitonvieira.helisistema.domain.Cidade;
import com.helitonvieira.helisistema.domain.Cliente;
import com.helitonvieira.helisistema.domain.Endereco;
import com.helitonvieira.helisistema.domain.enums.Perfil;
import com.helitonvieira.helisistema.domain.enums.TipoCliente;
import com.helitonvieira.helisistema.dto.ClienteDTO;
import com.helitonvieira.helisistema.dto.ClienteNewDTO;
import com.helitonvieira.helisistema.repositories.ClienteRepository;
import com.helitonvieira.helisistema.repositories.EnderecoRepository;
import com.helitonvieira.helisistema.security.UserSS;
import com.helitonvieira.helisistema.services.exceptions.AuthorizationException;
import com.helitonvieira.helisistema.services.exceptions.DataIntegrityException;
import com.helitonvieira.helisistema.services.exceptions.ObjectNotFoundException;

@Service
public class ClienteService {
	
	@Autowired
	private ClienteRepository repo;
	
	@Autowired
	private EnderecoRepository enderecoRepository;
	
	@Autowired
	private BCryptPasswordEncoder pe;
	
	@Autowired
	private S3Service s3Service;
	
	@Autowired
	private ImageService imageService;
		
	@Value("${img.prefix.client.profile}")
	private String prefix;
	
	@Value("${img.profile.size}")
	private Integer size;
	
	public Cliente find(Integer id) {
		
		UserSS user = UserService.authenticated();
		if (user==null || !user.hasRole(Perfil.ADMIN) && !id.equals(user.getId())) {
			throw new AuthorizationException("Acesso negado");
		}
		
		Optional<Cliente> obj = repo.findById(id);
		return obj.orElseThrow(() -> new ObjectNotFoundException(
				"Objeto não encontrado! Id: " + id + ", Tipo: " + Cliente.class.getName()));
	}
	
	@Transactional
	public Cliente insert(Cliente obj) {
		obj.setId(null);
		obj = repo.save(obj);
		enderecoRepository.saveAll(obj.getEnderecos());
		return obj;
	}
	
	public Cliente update(Cliente obj) {
		Cliente newObj = find(obj.getId());
		updateData(newObj, obj);
		return repo.save(newObj);
	}

	public void delete(Integer id) {
		find(id);
		try {
			repo.deleteById(id);
		}
		catch (DataIntegrityViolationException e) {
			throw new DataIntegrityException("Não é possível excluir porque há pedidos relacionados");
		}
	}
	
	public List<Cliente> findAll() {
		return repo.findAll();
	}
	
	public Cliente findByEmail(String email) {
		UserSS user = UserService.authenticated();
		if (user == null || !user.hasRole(Perfil.ADMIN) && !email.equals(user.getUsername())) {
			throw new AuthorizationException("Acesso negado");
		}
	
		Cliente obj = repo.findByEmail(email);
		if (obj == null) {
			throw new ObjectNotFoundException(
					"Objeto não encontrado! Id: " + user.getId() + ", Tipo: " + Cliente.class.getName());
		}
		return obj;
	}
	//page controla de quantos em quantos registro quer que carregue do banco de dados 
	//agiliza o processo de dados e consumo de memoria deixa pagina mais rapida
	//import org.springframework.data.domain.Page;	
	public Page<Cliente> findPage(Integer page, Integer linesPerPage, String orderBy, String direction) {
		               //findPage(qual a pagina vc quer começa do 0 , quantas linhas por pagina , qual campo vai ordenar , qual direçao ordenar acendente ou decendente)
		//import org.springframework.data.domain.PageRequest;    obj que prepara as consultas para Page
		PageRequest pageRequest = PageRequest.of(page, linesPerPage, Direction.valueOf(direction), orderBy);
		                        // PageRequest.of(qual a pagina , tamanho qtd linha , acendente descendente , campo de ordenaçao)    
		return repo.findAll(pageRequest);
	}
	
	public Cliente fromDTO(ClienteDTO objDto) {
		return new Cliente(objDto.getId(), objDto.getNome(), objDto.getEmail(), null, null, null);
	}
	
	public Cliente fromDTO(ClienteNewDTO objDto) {
		Cliente cli = new Cliente(null, objDto.getNome(), objDto.getEmail(), objDto.getCpfOuCnpj(), TipoCliente.toEnum(objDto.getTipo()), pe.encode(objDto.getSenha()));
		Cidade cid = new Cidade(objDto.getCidadeId(), null, null);
		Endereco end = new Endereco(null, objDto.getLogradouro(), objDto.getNumero(), objDto.getComplemento(), objDto.getBairro(), objDto.getCep(), cli, cid);
		cli.getEnderecos().add(end);
		cli.getTelefones().add(objDto.getTelefone1());
		if (objDto.getTelefone2()!=null) {
			cli.getTelefones().add(objDto.getTelefone2());
		}
		if (objDto.getTelefone3()!=null) {
			cli.getTelefones().add(objDto.getTelefone3());
		}
		return cli;
	}
	
	private void updateData(Cliente newObj, Cliente obj) {
		newObj.setNome(obj.getNome());
		newObj.setEmail(obj.getEmail());
	}
	
	public URI uploadProfilePicture(MultipartFile multipartFile) {
		UserSS user = UserService.authenticated();
		if (user == null) {
			throw new AuthorizationException("Acesso negado");
		}
		
		BufferedImage jpgImage = imageService.getJpgImageFromFile(multipartFile);
		jpgImage = imageService.cropSquare(jpgImage);
		jpgImage = imageService.resize(jpgImage, size);
		
		String fileName = prefix + user.getId() + ".jpg";
		
		return s3Service.uploadFile(imageService.getInputStream(jpgImage, "jpg"), fileName, "image");
	}
}

####################################################################
Biblioteca ou .jar
####################################################################
Biblioteca são os .jar projetos que vc podem utilizar em outros projetos 

COMO CRIAR O proprio .JAR

	btnDireito em cima do projeto > export > java > JAR file > Next > 
	JAR FILE (onde vai ser salvo e o nome do jar) C:\Users\Gugu\Desktop\calculadora.jar   
	next > next > finish
	
IMPORTAR A BIBLIOTECA .JAR PARA OUTRO PROJETO
        1- btnDireito em cima do projeto > propriedades > resouce  pega o caminho do projeto
        2- Abre no windows e cria uma pasta chamada lib
	3- Pega o .jar e coloca dentro desta pasta 
	4- BtnDireito Projeto > Build path > configure build path
	5- librares > add jar > espande projeto vai na pasta e seleciona
	O jar vai estar na Referencia Library pronto para uso
		

####################################################################
Heroku - instalar banco nas nuves aula 58 e 59 udemy  https://www.udemy.com/course/spring-boot-ionic/learn/lecture/8256790#overview
   CONFIGURAÇÃO
        Cria a conta no heroku 
	   vieirasystem2019@gmail.com faca,...........
	   helitondba@gmail.com faca,...........
        
	Cria a app (new app) https://dashboard.heroku.com/new-app
	   nome: app-estudo > salva
	   
	Adicionar o MySql 
	   informar cartao de credito caso utrapasse limite do plano gratis https://dashboard.heroku.com/account/billing
	   aba Overview > Configure Add-ons > pesquisa Mysql > Seleciona clearDB Mysql > selecione o plano gratis 

	Instale o Heroku CLI  https://devcenter.heroku.com/articles/heroku-cli#install-the-heroku-cli
		abra terminal cmd > digite: heroku login > (seta para cima > confirma  ou informe email e senha)
   
   ASSOCIAR VINCULAR O PROJETO LOCAL AO HEROKU	
	Abra o terminal gitbash na pasta do projeto 
        comando: (heroku git:remote -a nomeAppCriadoHeroku) 
	          heroku git:remote -a app-vsystem
	
	git remote -v  (verificação)
	    DEVE APARECER DESTA MANEIRA MOSTRANDO QUE O HEROKU ESTA VINCULADO 
		heroku  https://git.heroku.com/app-vsystem.git (fetch)
		heroku  https://git.heroku.com/app-vsystem.git (push)
		origin  https://github.com/helitonVieira/backEndAula1crudProduto.git (fetch)
		origin  https://github.com/helitonVieira/backEndAula1crudProduto.git (push)

      
   
   BACKUP MYSQL
	abra o cmd 
	selecione a pasta onde vai ficar o arquivo 
	comando: (mysqldump -u userBD -p nomeBD > nomeArquivoSeraCriado.sql)
	          mysqldump -u root -p vsystemevento > arquivo.sql
		  
   OBTER URL DO BANCO DE DADOS HEROKU
	abra o git bash na pasta do projeto 
	comando: heroku config | grep CLEARDB_DATABASE_URL
		mysql://bebe10e13815ed:ce289ab2@us-cdbr-east-05.cleardb.net/heroku_c56081e8e9a6e9a?reconnect=true
	
	MONTAR O COMANDO PARA SUBIR SCRIPT DO BACKUP(mysql --host= --user= --password= --reconnect < arquivoBKP.sql)		
		mysql --host=us-cdbr-east-05.cleardb.net --user=bebe10e13815ed --password=ce289ab2 --reconnect heroku_c56081e8e9a6e9a < arquivo.sql
           
        SUBIR O SCRIPT DO BANCO DE DADOS PARA HEROKU
	   Abra cmd
	   entre no caminho que esta o back do banco 
	   executa o comando criado a cima mysql --host=us-cdbr-east-05.cleardb.net --user=bebe10e13815ed --password=ce289ab2 --reconnect heroku_c56081e8e9a6e9a < arquivo.sql	   
	   
	   
   CRIAR APPLICATION.PROPERTIES DE PRODUÇÃO 

	spring.datasource.url=mysql://bebe10e13815ed:ce289ab2@us-cdbr-east-05.cleardb.net/heroku_c56081e8e9a6e9a?reconnect=true

        spring.jpa.hibernate.ddl-auto=none
        spring.jpa.show-sql=false
        spring.jpa.properties.hibernate.format_sql=false
	
   CRIE O ARQUIVO Procfile na raiz do projeto para comunicar com heroku

	(troque pelo nome do seu projeto):
	web: java -Dserver.port=$PORT -Dspring.profiles.active=prod $JAVA_OPTS -jar 
		
			target/cursomc-0.0.1-SNAPSHOT.jar
		Notas:
		      -D serve para passar parâmetros ao Heroku
		      $PORT é a variável em que o Heroku armazena a porta pela qual a API vai ser acessada
		      Para gerar o .jar do projeto: 
		      Window -> Preferences -> Installed JREs
		      Selecione o item existente e clique Edit
		      Clique Directory e selecione a pasta do JDK (não a do JRE), clique Finish
		      Clique Apply and Clone
		      Clique Project -> Clean
		      Run As -> Maven Install (o banco de dados precisa estar online)
		      Verifique o arquivo .jar gerado na pasta target
		      
CRIAR O ARQUIVO (system.properties) na raiz do projeto para informar a versao do java para heroku	
			java.runtime.version=11
			
			
POM.XML deve conter o plugin	

	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>
			
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-resources-plugin</artifactId>				
			</plugin>
		</plugins>
	</build>


no heroku click em OPEN APP Pegar o caminho que esta sua aplicação testar no postman
	https://app-vsystem.herokuapp.com	
			
####################################################################

############################
application.properties   https://www.youtube.com/watch?v=_7ttFUC26LQ
############################
No application.properties 

TROCAR A PORTA 8080
	server.port = 8090

DECLARAR A VARIAVEL   
	variavel = valorVariavel
        BigDecimal valorTotal ;
	nome = Heliton Silva Vieira

Criar as variaveis que vai ser utilizada em todo sistema


Chamando a variavel na classe

Criando variavel 
	1)variavel simples
	@Value("${nome:Passar Valor Defaut}")
	private String varCriada;
	
    2)Passando um valor Default coloca o : e passa o valor 

	@Value("${nome:Juliana Andrade Rocha}") // se nao tiver nenhum pega o default
	private String varCriada;
	
VALOR NULL AO TENTAR PEGAR A VARIAVEL (Principalmente quando esta iniciando )
	Obs: application.properties não aceita variaveis staticas desta forma conseguimos fazer a conversao

	private static String nome;
	@Value("${url.endpoint.dotnet}")
	public void setNome(String url) {
		nome = url;
	}	
	
TAMBEM PODE ATRIBUIR VALOR PASSADO PELA VARIAVEL DE AMBIENTE

		btnDireito > Run as > Run Configuration 
			Environment
			Add nomeVariavel e valor
			
OBSERVAÇÃO A ORDEM QUE PEGA O VALOR DA VARIAVEL CRIADA NO APPLICATION.PROPERTIES
				1 - VARIAVEL DE AMBIENTE
				2 - APPLICATION.PROPERTIES
				3 - DEFAULT CRIADO NA CLASSE

CONEXAO COM BANCOS DE DADOS 

####################################################################
Autenticação e Autorização token JWT  autorização trafegada cabeçarios das requisiçoes pela url, controla o usuario e tempo de inspiração do token
(mais abaixo ver os 2 separados)
Altenticação sistema verifica se o usuario e um usuario valido 
Autorização processo de identificar qual recurso o usuario pode acessar 
####################################################################
 Incluir as dependências no pom.xml

	1)	<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-security</artifactId>
		</dependency>
		
		
		

		<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt</artifactId>
			<version>0.7.0</version>
		</dependency>
		
		APOS INFORMAR O SISTEMA JA NAO RODA SEM A AUTORIZAÇÃO CHAVE TOKEN
	
    2)	Dentro da pacote de config cria a class SecurityConfig
		

-------------------------------------
Senha  BCryptPasswordEncoder cria um @Bean que pode ser usado em todo sistema pacote config class SecurityConfig
-------------------------------------
     Incluir um Bean de BCryptPasswordEncoder no arquivo de configuração
		@Bean //criando um bean de senha para criptrografar a senha 
		public BCryptPasswordEncoder bCryptPasswordEncoder() { 
			return new BCryptPasswordEncoder();
		}
	
	
	 Incluir um atributo senha na classe Cliente
		@JsonIgnore    //para nao aparecer nao busca 
		private String senha;
		//get e set  add no contrutor com argumento buscar null 
	 Atualizar ClienteNewDTO
		@NotEmpty(message="Preenchimento obrigatório")
		private String senha;
		//get e set 
	 Atualizar ClienteService
		@Autowired
		private BCryptPasswordEncoder pe; // BCryptPasswordEncoder criptografia criada no pacote config na class SecurityConfig
	    
		public Cliente fromDTO(ClienteNewDTO objDto) {
		//na hora de converter chama pe.encode 
		Cliente cli = new Cliente(null, objDto.getNome(), objDto.getEmail(), objDto.getCpfOuCnpj(), TipoCliente.toEnum(objDto.getTipo()), pe.encode(objDto.getSenha())); //pe.encode(objDto.getSenha()) criptrografando a senha 
		Cidade cid = new Cidade(objDto.getCidadeId(), null, null);
		Endereco end = new Endereco(null, objDto.getLogradouro(), objDto.getNumero(), objDto.getComplemento(), objDto.getBairro(), objDto.getCep(), cli, cid);
		cli.getEnderecos().add(end);
		cli.getTelefones().add(objDto.getTelefone1());
		if (objDto.getTelefone2()!=null) {
			cli.getTelefones().add(objDto.getTelefone2());
		}
		if (objDto.getTelefone3()!=null) {
			cli.getTelefones().add(objDto.getTelefone3());
		}
		return cli;
	}
	
	 Atualizar DBService
		private BCryptPasswordEncoder pe; 
		// na hora de gravar chama o pe.encode
		Cliente cli1 = new Cliente(null, "Heliton Silva Vieira", "helitondba@gmail.com", "123", TipoCliente.PESSOAFISICA, pe.encode("123"));
		

-------------------------------------------------
Criação de Perfil de usuario 
-------------------------------------------------
 Criar o tipo enumerado Perfil (CLIENTE, ADMIN)
	
	package com.helitonvieira.helisistema.domain.enums;

public enum Perfil {
	
	ADMIN(1, "ROLE_ADMIN"), //ROLE_  é uma exigencia do springSecurity 
	CLIENTE(2, "ROLE_CLIENTE");
	
	private int cod;
	private String descricao;
	
	private Perfil(int cod, String descricao) {
		this.cod = cod;
		this.descricao = descricao;
	}
	
	public int getCod() {
		return cod;
	}
	
	public String getDescricao () {
		return descricao;
	}
	
	public static Perfil toEnum(Integer cod) {
		
		if (cod == null) {
			return null;
		}
		
		for (Perfil x : Perfil.values()) {
			if (cod.equals(x.getCod())) {
				return x;
			}
		}
		
		throw new IllegalArgumentException("Id inválido: " + cod);
	}

}


 Implementar na classe Cliente:
	@ElementCollection(fetch=FetchType.EAGER)// para garantir que sempre que busque um cliente venha o tipo perfil admin ou cliente
	@CollectionTable(name="PERFIS")
	private Set<Integer> perfis = new HashSet<>();
	
	//get set 
	// meto para retornar o perfil convertendo de numeric para a string armazenada na class
	public Set<Perfil> getPerfis() {
		return perfis.stream().map(x -> Perfil.toEnum(x)).collect(Collectors.toSet());
	}
	//metodo para adcionar perfil 
	public void addPerfil(Perfil perfil) {
		perfis.add(perfil.getCod());
	}
	
 public void addPerfil(Perfil perfil)
 Incluir perfil padrão (CLIENTE) na instanciação de Cliente
 Incluir mais um cliente com perfil ADMIN na carga inicial da base de dados (DBService)

############################
Autenticação - pessoa se identifica sistema faz a autenticação verificando se esta correto
############################

 Criar classe de usuário conforme contrato do Spring Security (implements UserDetails)
	*pacote security class UserSS
	
	
 Criar classe de serviço conforme contrato do Spring Security (implements UserDetailsService)
 Em SecurityConfig, sobrescrever o método: public void configure(AuthenticationManagerBuilder auth)

 Criar a classe CredenciaisDTO (usuário e senha)
	public class CredenciaisDTO implements Serializable {
		private static final long serialVersionUID = 1L;
		
		private String email;
		private String senha;
		//construtor vazio get e set 
		
 Incluir as propriedades de JWT (segredo e tempo de expiração) em application.properties
	jwt.secret=SequenciaDeCaracteresParaAssinarToken
    jwt.expiration=86400000   // tempo para inspirar o token (60000 equivale a 1 min)

 Criar uma classe JWTUtil (@Component) com a operação String generateToken(String username)
	//pacote security class JWTUtil


 Criar um filtro de autenticação (ele verifica se o usuario e senha esta correto na inserçao)
	//pacote security class JWTAuthenticationFilter
	
	
 Em SecurityConfig, registrar o filtro de autenticação

---------------------------------------------
Autorização - quando passa o token na atenticação do login apos autenticação fazer as autorização dos endpoits
---------------------------------------------
 Criar um filtro de autorização

o Acrescentar uma função em JWTUtil para verificar se um dado token é válido
 Em SecurityConfig, registrar o filtro de autorização
Autorizando endpoints para perfis específicos



##########################################
criptografia usando BCryptPasswordEncoder
##########################################
@Bean
	public PasswordEncoder passwordEncoder() {
		return new BCryptPasswordEncoder();  // descriptografar pode ser chamado PasswordEncoder passwordEncoder devido a criação do @Bean
	}

	public static void main(String[] args) {
		System.out.println(new BCryptPasswordEncoder().encode("123"));//criado simpresmente para pegar no console o 123 codificado
	}
##########################################
 Exemplo de conexão com Java Puro 
 ##########################################

https://www.youtube.com/watch?v=jl0rfsVX1ss


public static void sendGet2(CalculoSeguroRequest request, TokenResponse tokenResponse) {

		String urlDesc = "https://ymtj-srv-cadastramento-contas-pjl2.pj.cloud.corpd.bradesco.com.br/api/v1/consultar/agencia/6505/conta/5401/digito/01/controle/0/qtdOcorrencia/010/ultCrBanco/0/ultCrAgencia/0/ultCrConta/0/ultCrTpCta/0";

		HttpURLConnection connection = null;
		BufferedReader reader = null;

		try {
			
			System.setProperty("javax.net.ssl.trustStore", "C:/.keystore");
			System.setProperty("javax.net.ssl.trustStorePassword", "changeit");

			URL url = new URL(urlDesc);
			connection = (HttpURLConnection) url.openConnection();
			connection.setRequestMethod("GET");
			connection.addRequestProperty("x-stateless-open",
					"eyJwZXJpZmVyaWNvIjoiT1BFTkJBTktJTkciLCJpZGlvbWEiOiIxIiwiY2FuYWwiOjU0MSwiZW1wcmVzYSI6MjM3LCJ1dWlkIjoiMDM3ODU5YjItMmMzNS00ZjJjLWEwYzktOWIxNTM0NmI2N2E0IiwiZGVwZW5kZW5jaWEiOjF9");
			connection.addRequestProperty("x-stateless-closed",
					"eyJmcndrIjp7InRpY2tldCI6IkJBQjFFMDg2NzFDMDkyMjAwMDAyIiwiaWRzZXNzYW8iOiIwMTM0MTc2MTZBMUE1RDJIMDFGNEE3MDYxQTJGODY3RiIsInRpcG9Vc3VhcmlvIjoiQ1BGIiwidXN1YXJpbyI6IjI2Njg4MTk4ODE5In19");
			reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
			StringBuilder jsonSB = new StringBuilder();
			String line;

			while ((line = reader.readLine()) != null) {
				jsonSB.append(line);
			}

			System.out.println(jsonSB.toString());

		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			IOUtils.closeQuietly(reader);

			if (connection != null) {
				connection.disconnect();

			}
		}
	}
##########################################
RestTemplate  - https://www.youtube.com/watch?v=2163qLWZraY
##########################################

		OBSERVAÇÃO USE O @JsonProperty("cTpoCusto") NO OBJETO DE RETORNO CASO NAO ESTEJA RETORNANDO OS DADOS

 
--explicação 
classe response tem que ter o toString para melhor visualizar

existe 3 tipos 

	restTemplate.getForObject()      // retorna o objeto ClienteResponse direto 
	restTemplate.getForEntity()      // retorna o ResponseEntity<ClienteResponse> com mais informação status etc... 
	restTemplate.exchange  // vc pode usar para get e para post 
	
---------------------------
EX: 1 SIMPLES  getForObject

	String url = "https://brai-srv-cons-gestaoparam-corp"  //não pode ter barra no final erro url not absolute
	RestTemplate restTemplate = new RestTemplateBuilder()
		.rootUri("url")
		.basicAuthorization(username:"gugu", password:"123")
		.build();
		
ClienteResponse clientes =	restTemplate.getForObject("/{id}", //ja declarado em cima não precisa colocar url inteira obs a barra / sempre alqui
		ClienteResponse.class,         //classe de response
		1); // os parametros informado no {id}
		
		System.out.println(clientes);
	
---------------------------
EX: 2 getForEntity RETORNA UM ResponseEntity

String url = "https://brai-srv-cons-gestaoparam-corp"  
	RestTemplate restTemplate = new RestTemplateBuilder()
		.rootUri("url")
		.basicAuthorization(username:"gugu", password:"123")
		.build();
		
ResponseEntity<ClienteResponse> clientes =	restTemplate.getForEntity("/{id}",  
		ClienteResponse.class,          
		1); 
		
		System.out.println(clientes.getBody());
		
---------------------------		
EX: 3  getForObject RETORNANDO LISTA

	String url = "https://brai-srv-cons-gestaoparam-corp" 
	RestTemplate restTemplate = new RestTemplateBuilder()
		.rootUri("url")
		.basicAuthorization(username:"gugu", password:"123")
		.build();
		
ClienteResponse[] clientes =	restTemplate.getForObject("/{id}", 
		ClienteResponse[].class,         
		1); 
		
		System.out.println( Arrays.toString(clientes));

	
---------------------------
EX: 4 restTemplate.exchange RETORNA UM ResponseEntity

String url = "https://brai-srv-cons-gestaoparam-corp"  
	RestTemplate restTemplate = new RestTemplateBuilder()
		.rootUri("url")
		.basicAuthorization(username:"gugu", password:"123")
		.build();
		
ResponseEntity<List<ClienteResponse>> clientes =	restTemplate.exchange("/",  //complemento da url  
	HttpMethod.GET,   //metodo se GET ou POST
	new HttpEntity<>(headers),
	new ParameterizedTypeReference<List<ClienteResponse>>() {	
	}).getBody();
		
		System.out.println(clientes.getBody());
		
		
---------------------------
EX: 5 restTemplate.exchange trabalhar com paginação    https://www.youtube.com/watch?v=AapEEmyTt2s

1) criar um model PageableResponse

String url = "https://brai-srv-cons-gestaoparam-corp"  
	RestTemplate restTemplate = new RestTemplateBuilder()
		.rootUri("url")
		.basicAuthorization(username:"gugu", password:"123")
		.build();
		
ResponseEntity<List<ClienteResponse>> clientes =	restTemplate.exchange("/",  //complemento da url  
	HttpMethod.GET,   //metodo se GET ou POST
	new HttpEntity<>(headers),
	new ParameterizedTypeReference<List<ClienteResponse>>() {	
	}).getBody();
		
		System.out.println(clientes.getBody());		
		
		
Cliente Spring com RestTemplate pt 01 GET

public TGstaoParmProdtEmptmFinan sendGet(CalculoSeguroRequest request, TokenResponse tokenResponse,HttpHeaders headers) {
		
		String urlDesc = "https://brai-srv-cons-gestaoparam-corp.corp.cloud.corpd.bradesco.com.br/v1/produtos/legados/12/961/regrasGerais?fromDateReferenceSearch=1990-10-10&toDateReferenceSearch=2050-10-10&page=1&size=5";

		StringBuilder url = new StringBuilder();
		//url.append(caleUrl).append("calcular/").append(dataInicio).append("/").append(dataFinal).append("?idPais=9").append("&ultimoDiaAnoUtil=true");
		
		url.append(urlDesc);
		
		LOGGER.info("Efetuando consulta na API cadastro para a URL: {}", url);
		
		CaleVerificaSeDiaUtilResponse cale = sendGet3(request, tokenResponse,HttpHeaders.EMPTY);

		try {

			return restTemplate.exchange(url.toString(), 
					HttpMethod.GET, new HttpEntity<>(headers),
					new ParameterizedTypeReference<TGstaoParmProdtEmptmFinan>() {
					}).getBody();

		} catch (HttpServerErrorException e) {
			throw new ExternalServiceException(ERRO_EXTERNO_DO_SERVICO_CADASTRO, e, e.getLocalizedMessage());
		} catch (Exception e) {
			throw new GatewayAccessException(ERRO_AO_ACESSAR_A_URL_CADASTRO, e, e.getLocalizedMessage());
		}
		
	}
	
	EX RESTTEMPLATE POST 
	
	
	@Override
	public CalculoSeguroResponse sendGet(CalculoSeguroRequest body, Map<String, String> headers) {
		
			try {			
		
				url = "http://localhost:8080/v1/calculoSeguro" ;		
				
				HttpHeaders header = new HttpHeaders();
				
				for (Map.Entry<String, String> entry : headers.entrySet()) {		
				    
					header.add(entry.getKey(), entry.getValue());
				}
					

			
			LOGGER.info("Efetuando consulta na API Calculo Seguro para a URL: {}", url);
		
			ResponseEntity<CalculoSeguroResponse> response = restTemplate.exchange(
					url, 
					HttpMethod.POST, 
					new HttpEntity<>(body,header),
					new ParameterizedTypeReference<CalculoSeguroResponse>() {})
					;
			
			
			
			return response.getBody();
			
			

		} catch (RestClientException e) {
			LOGGER.error(ERRO_EXTERNO_DO_SERVICO_CADASTRO, e);
			throw new MsgException(500, ERRO_AO_ACESSAR_A_URL_CADASTRO, e.getLocalizedMessage());
		} catch (Exception e) {
			LOGGER.error(ERRO_AO_ACESSAR_A_URL_CADASTRO, e);
			throw new GatewayAccessException(ERRO_AO_ACESSAR_A_URL_CADASTRO, e, e.getLocalizedMessage());
		}
	}


#############################################
Thread synchronized
#############################################

https://www.youtube.com/watch?v=9TtULlGYG6U&list=PLuYctAHjg89YNXAXhgUt6ogMyPphlTVQG&index=5

Entendendo Threads (NAO RECOMENDADO QUANDO TEM MUITOS CALCULOS,
			UMA VARIAVEL QUE PERCORE TODO O CODIGO PODE SOFRER ALTERAÇAO PELA OUTRA THREAD)

paralelismo  quando threds diferente nao usam a msm variavel
concorencia quando threds diferente usam a msm variavel

computador tem que ter mais de 1 nucleo para o paralelismo 
Um unico nucleo ele vai decidindo qtas linhas passa de cada thread



PARA EVITAR CONCORENCIA UTILIZAMOS O SYNCHRONIZED (NAO USA PARA COLEÇÕES E LISTAS)
Quando utilizar 
* Quando temos variaveis que muda de valor durante o percurso muitos calculos 

1) isolamento no metodo (DESVANTAGEM VC ACABA COM O PARALELISMO USO DA Threads POIS VAI ACONTECER UM ENFILERAMENTO QUE VAI PASSAR UMA DE CADA VEZ)

	public synchronized soma(double a , double b){
		//dados dentro do metodo
	}
2) isolamento em parte do codigo
	synchronized(this) {	
		//codigo que vai ficar na fila 
	}
	
	
3) mais de 1 isolamento criar variaveis para 1 nao ficar esperando o outro

	static Object lock1 = new Object();
	static Object lock2 = new Object();
	
	synchronized(lock1) {	
		//codigo que vai ficar na fila 
	}
	
	synchronized(lock2) {	
		//codigo que vai ficar na fila 
	}
	
4) CORRETO A SER USADO 
	*DESCOBRIR O RECURSO QUE ESTA COM CONCORENCIA
	*FAZER O ISOLAMENTO SOMENTE DA PARTE QUE TEM A CONCORENCIA
	
	EX: abaixo temos a variavel "i" que é utilizada por todas as threads neste caso isolamos somente ela

    int j
	
	synchronized(this) {	
		 i++;
		 j = i + 2;
	}
	
	double jElevado = Math.pow(j,100);
	
	
	
LIST E COLECTIONS 
Acontece um problema de sumir algumas threads nao chega no final e nao apresenta msg de erro 
resolver este problema 

	1) 

    	private static List<String> lista = ArrayList<>();
		
		public static soma(){
		//solucao garante que todas vai aparecer 
		
		lista = Collections.synchronizedList(lista);
		
		/*Outras que pode ser usadas*/
		
		lista = Collections.synchronizedList(lista);
		lista = Collections.synchronizedCollection(lista);
		lista = Collections.synchronizedMap(lista);
		lista = Collections.synchronizedSet(lista);
		
		
		}
	
	2) alterando logo na criação da variavel  CopyOnWriteArrayList   (pesado que faz uma copia do array inteiro, nao usar quando tem varios add e remove)
	
	private static List<String> lista = CopyOnWriteArrayList<>();
	
	private static Map<Integer,String> lista = ConcurrentHashMap<>();

##########################################
Docker - 
##########################################

	docker - ferramenta de empacotamento de uma aplicação e suas dependencias 
	em um container que pode ser executado em um servidor linux.
	
	-Ambiente de execução auto-contido
	-kernel compartilhado com host
	-isolamento dos demais containeres
	-baixo overhead e tempo de boot 
	
	Funcionamento e parecido com uma VM (maquina virtual) mais nao é uma VM
	
	1- Maquina virtual(VM)
		  -harduware > sitema Operacional > Hipervisor > sistema operacional > bibliotecas e aplicações
		
	2- Docker
		  -harduware > sitema Operacional > Docker Engine > bibliotecas e aplicações
		
	
instalando o docker	
  comandos do linux
	$ wget -qO https://get.docker.com/ | sh
	
	$ sudo usermod -aG docker <usuario>
	
	Pode usar os instaladores do docker.com
	

Subindo um container 

	$ docker run --name container-teste ubuntu:14.04
	
		
		
********************************************************************
Configuração e envio projeto Heroku subir base e aplicação aula 58 a 60 
********************************************************************		


####################################################################
POSTMAN
####################################################################
POST
    {
        "nome": "FANTA UVA",
        "codSubcategoria": {
            "id": 1,
            "descricao": "REFRIGERANTE"
        },
        "preco": 4.87
    }
	
GET (passa os valores pela URL)

	http://localhost:8080/ymtj-srv-transferencia/api/v1/programacao/consultarProgramacao/agencia/6505/conta/5401


New Environment (para criar variaveis fixas e não ficar precisando copiar coloar senha )


Headers 

Content-Type = application/json



####################################################################
Swagger
####################################################################  


Swagger (simplificar o desenvolvimento e documentar api)

SWAGGER EDITOR (Onde criamos as especificações do nosso swagger ) htts://editor.swagger.io
SWAGGER CODEGEN (Usamos nas linguagens @.... este usamos no java)
SWAGGER UI (Parte visual dos endpoint que conseguimos testar )

Schema (criar componentes 
         reduzir codigo )
		 
Segurança (autenticação dos campos no swagger ui aparece com um cadeado)
		
		
####################################################################
Testes unitarios 
####################################################################	
		
JUNIT	https://www.vogella.com/tutorials/JUnit/article.html



assertEquals = assertEquals(4, calculadora.multiply(2, 2),"mensagem de falha opcional");

assertTrue = assertTrue('a' < 'b', () → "mensagem de falha opcional");

assertFalso = assertFalse('a' > 'b', () → "mensagem de falha opcional");

assertNotNull = assertNotNull(yourObject, "mensagem de falha opcional");

assertNull = assertNull(yourObject, "mensagem de falha opcional");


 VISÃO GERAL DAS ANOTAÇÕES JUNIT5		
 
 
 @Test
Identifica um método como um método de teste.

@Disabled("reason")
Desabilita um método de teste com um motivo de opção.

@BeforeEach
Executado antes de cada teste. Usado para preparar o ambiente de teste, por exemplo, inicializar os campos na classe de teste, configurar o ambiente, etc.

@AfterEach
Executado após cada teste. Usado para limpar o ambiente de teste, por exemplo, excluir dados temporários, restaurar padrões, limpar estruturas de memória caras.

@DisplayName("<Name>")
<Nome> que será exibido pelo executor de teste. Ao contrário dos nomes de métodos, o nome pode conter espaços para melhorar a legibilidade.

@RepeatedTest(<Number>)
Semelhante a, @Testmas repete o teste um <Número> de vezes

@BeforeAll
Anota um método estático que é executado uma vez, antes do início de todos os testes. Ele é usado para realizar atividades intensivas em tempo, por exemplo, para se conectar a um banco de dados. Os métodos marcados com esta anotação precisam ser definidos staticpara funcionar com JUnit.

@AfterAll
Anota um método estático que é executado uma vez, após a conclusão de todos os testes. Ele é usado para realizar atividades de limpeza, por exemplo, para se desconectar de um banco de dados. Os métodos anotados com esta anotação precisam ser definidos staticpara funcionar com JUnit.

@TestFactory
Anota um método que é uma Fábrica para criar testes dinâmicos

@Nested
Permite aninhar classes de teste internas para agrupar seus testes e ter métodos @BeforeEach e @AfterEach adicionais.

@Tag("<TagName>")
Tags um método de teste, testes no JUnit 5 podem ser filtrados por tag. Por exemplo, execute apenas testes marcados com "rápido".

@ExtendWith
Permite registrar uma classe Extension que adiciona funcionalidade aos teste



--------------
MOCK MOCKITO  https://www.vogella.com/tutorials/Mockito/article.html
--------------
		
		
	public int getUniqueId() {
        return 42;
    }
	
	//MOCK definindo que o retorno do metodo seja 42
	when(databaseMock.getUniqueId()).thenReturn(42);
		
		